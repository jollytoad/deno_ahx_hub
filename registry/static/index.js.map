{
  "version": 3,
  "sources": ["../../../ahx_lib/lib/ready.ts", "../../../ahx_lib/lib/util/internal.ts", "../../../ahx_lib/lib/config.ts", "../../../ahx_lib/lib/util/dispatch.ts", "../../../ahx_lib/lib/util/names.ts", "../../../ahx_lib/lib/util/owner.ts", "../../../ahx_lib/lib/parse_css_value.ts", "../../../ahx_lib/lib/parse_attr_value.ts", "../../../ahx_lib/lib/parse_triggers.ts", "../../../ahx_lib/lib/parse_actions.ts", "../../../ahx_lib/lib/parse_interval.ts", "../../../ahx_lib/lib/parse_swap.ts", "../../../ahx_lib/lib/util/query_selector.ts", "../../../ahx_lib/ext/polyfill/ReadableStream_asyncIterator.js", "../../../ahx_lib/ext/HTMLBodyElementParserStream.js", "../../../ahx_lib/lib/util/slots.ts", "../../../ahx_lib/lib/swap_html.ts", "../../../ahx_lib/lib/swap_attr.ts", "../../../ahx_lib/lib/swap_input.ts", "../../../ahx_lib/lib/swap_text.ts", "../../../ahx_lib/lib/handle_swap.ts", "../../../ahx_lib/lib/handle_request.ts", "../../../ahx_lib/lib/handle_harvest.ts", "../../../ahx_lib/lib/handle_action.ts", "../../../ahx_lib/lib/util/queue.ts", "../../../ahx_lib/lib/handle_trigger.ts", "../../../ahx_lib/lib/util/event.ts", "../../../ahx_lib/lib/util/rules.ts", "../../../ahx_lib/lib/util/controls.ts", "../../../ahx_lib/lib/parse_target.ts", "../../../ahx_lib/lib/event_listener.ts", "../../../ahx_lib/lib/util/resolve_element.ts", "../../../ahx_lib/lib/process_control.ts", "../../../ahx_lib/lib/process_controls.ts", "../../../ahx_lib/lib/process_slot.ts", "../../../ahx_lib/lib/process_element.ts", "../../../ahx_lib/lib/process_elements.ts", "../../../ahx_lib/lib/trigger_mutate.ts", "../../../ahx_lib/lib/trigger_load.ts", "../../../ahx_lib/lib/process_guards.ts", "../../../ahx_lib/lib/process_pseudo_elements.ts", "../../../ahx_lib/lib/process_css_imports.ts", "../../../ahx_lib/lib/process_rule.ts", "../../../ahx_lib/lib/process_rules.ts", "../../../ahx_lib/lib/process_queue.ts", "../../../ahx_lib/lib/start_observer.ts", "../../../ahx_lib/lib/debug.ts", "../../../ahx_lib/lib/debug/internals.ts", "../../../ahx_lib/lib/debug/events.ts", "../../../ahx_lib/lib/debug/compare_position.ts", "../../../ahx_lib/lib/debug/elements.ts", "../../../ahx_lib/lib/debug/controls.ts", "../../../ahx_lib/lib/debug/owners.ts", "../../../ahx_lib/lib/debug/forms.ts", "../../../ahx_lib/lib/debug/slots.ts", "../../../ahx_lib/lib/url_attrs.ts", "../../../ahx_lib/lib/ahx.ts"],
  "sourcesContent": ["let isReady = false;\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  isReady = true;\n}, { once: true, passive: true });\n\nexport function ready(fn: (document: Document) => void) {\n  if (isReady) {\n    fn(document);\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", () => fn(document), {\n      once: true,\n      passive: true,\n    });\n  }\n}\n", "import type {\n  ControlDecl,\n  ControlSpec,\n  EventType,\n  Owner,\n  PseudoId,\n  RuleId,\n} from \"../types.ts\";\n\ntype Thing = Node | CSSRule | StyleSheet;\n\ntype ControlProps = {\n  [K in `control:${EventType}`]: ControlSpec;\n};\n\n/** Records that a control has been triggered once on an element for an event type */\ntype TriggeredProps = {\n  [K in `triggered:${EventType}`]: WeakSet<ControlDecl>;\n};\n\ninterface Props extends ControlProps, TriggeredProps {\n  // CSSStyleRule\n  \"ruleId\": RuleId;\n  \"pseudoId\": PseudoId;\n  \"importLinks\": Map<string, WeakRef<HTMLLinkElement>>;\n  \"denyTrigger\": true;\n  \"slotName\": Set<string>;\n\n  // Element\n  \"delayed\": ReturnType<typeof setTimeout>;\n  \"formData\": FormData;\n\n  // Common\n  \"owner\": Owner;\n}\n\nexport type Key = keyof Props;\n\nconst values = new Map<Key, WeakMap<Thing, Props[Key]>>();\n\n// Maintain an iterable set of WeakRefs to the objects with internal properties\nconst weakRefs = new Set<WeakRef<Thing>>();\nconst toWeakRef = new WeakMap<Thing, WeakRef<Thing>>();\n\n/**\n * Set an internal property associated with a DOM object\n */\nexport function setInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n  value: Props[K],\n) {\n  if (!values.has(key)) {\n    values.set(key, new WeakMap());\n  }\n\n  values.get(key)!.set(obj, value);\n\n  if (!toWeakRef.has(obj)) {\n    const weakRef = new WeakRef(obj);\n    weakRefs.add(weakRef);\n    toWeakRef.set(obj, weakRef);\n  }\n}\n\n/**\n * Get an internal property from a DOM object.\n * Optionally initializing that property if it doesn't already exist,\n * this is handy where the property is a Map or Set.\n */\nexport function getInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n  initializer: () => Props[K],\n): Props[K];\nexport function getInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n): Props[K] | undefined;\nexport function getInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n  initializer?: () => Props[K],\n): Props[K] | undefined {\n  if (initializer && !hasInternal(obj, key)) {\n    setInternal(obj, key, initializer());\n  }\n  return values.get(key)?.get(obj) as Props[K] | undefined;\n}\n\n/**\n * Check whether a internal property exists on a DOM object.\n */\nexport function hasInternal(obj: Thing, key: Key): boolean {\n  return !!values.get(key)?.has(obj);\n}\n\n/**\n * Delete one or all internal properties from a DOM object.\n */\nexport function deleteInternal(obj: Thing, key?: Key): void {\n  if (key) {\n    values.get(key)?.delete(obj);\n  } else {\n    for (const valueMap of values.values()) {\n      valueMap.delete(obj);\n    }\n    const weakRef = toWeakRef.get(obj);\n    if (weakRef) {\n      weakRefs.delete(weakRef);\n      toWeakRef.delete(obj);\n    }\n  }\n}\n\n/**\n * Clone important internal values from one thing to another.\n * At present this is just the \"triggered:\" props.\n */\nexport function cloneInternal(src: Thing, dst: Thing) {\n  for (const [key, valueMap] of values.entries()) {\n    if (key.startsWith(\"triggered:\")) {\n      const value = valueMap.get(src);\n      if (value !== undefined) {\n        setInternal(dst, key, value);\n      }\n    }\n  }\n}\n\n/**\n * Find all DOM objects that have a specific internal property set.\n * @returns tuples of the object and its property value\n */\nexport function* objectsWithInternal<K extends Key>(\n  key: K,\n): Iterable<[Thing, Props[K]]> {\n  const valueMap = values.get(key);\n  if (valueMap) {\n    for (const weakRef of weakRefs) {\n      const obj = weakRef.deref();\n      if (obj && valueMap.has(obj)) {\n        yield [obj, valueMap.get(obj) as Props[K]];\n      }\n    }\n  }\n}\n\n/**\n * Iterate across all internal properties of all objects\n * @returns tuples of an object, property key, and property value on the object\n */\nexport function* internalEntries<K extends Key>(): Iterable<\n  [Thing, K, Props[K]]\n> {\n  for (const weakRef of weakRefs) {\n    const thing = weakRef.deref();\n    if (thing) {\n      for (const [key, valueMap] of values.entries()) {\n        if (valueMap.has(thing)) {\n          yield [thing, key as K, valueMap.get(thing) as Props[K]];\n        }\n      }\n    }\n  }\n}\n", "import type { AhxHttpMethod, ControlPropName, Prefix } from \"./types.ts\";\n\ninterface Config {\n  prefix: Prefix;\n  httpMethods: AhxHttpMethod[];\n  ahxAttrs: ControlPropName[];\n  maxLoopCount: number;\n  defaultDelay: number;\n  defaultSettleDelay: number;\n  defaultSwapDelay: number;\n  enableDebugEvent: boolean;\n  pseudoChildTags: Record<string, string | null | undefined>;\n}\n\nexport const config: Config = {\n  prefix: \"ahx\",\n\n  httpMethods: [\n    \"get\",\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\",\n  ],\n\n  ahxAttrs: [\n    \"trigger\",\n    \"target\",\n    \"slot-name\",\n  ],\n\n  maxLoopCount: 10,\n\n  defaultDelay: 20,\n  defaultSettleDelay: 20,\n  defaultSwapDelay: 0,\n\n  enableDebugEvent: false,\n\n  // parent tag -> default child pseudo tag (or null if a child is not permitted)\n  pseudoChildTags: {\n    \"article\": \"div\",\n    \"aside\": \"div\",\n    \"audio\": \"track\",\n    \"body\": \"div\",\n    \"canvas\": null,\n    \"colgroup\": \"col\",\n    \"datalist\": \"option\",\n    \"div\": \"div\",\n    \"dl\": \"dt\",\n    \"footer\": \"div\",\n    \"form\": \"fieldset\",\n    \"head\": null,\n    \"header\": \"div\",\n    \"hgroup\": \"div\",\n    \"html\": null,\n    \"iframe\": null,\n    \"main\": \"div\",\n    \"map\": \"area\",\n    \"menu\": \"li\",\n    \"noscript\": null,\n    \"object\": null,\n    \"ol\": \"li\",\n    \"optgroup\": \"option\",\n    \"p\": \"span\",\n    \"picture\": \"source\",\n    \"portal\": null,\n    \"pre\": null,\n    \"script\": null,\n    \"section\": \"div\",\n    \"select\": \"option\",\n    \"span\": \"span\",\n    \"style\": null,\n    \"table\": \"tbody\",\n    \"tbody\": \"tr\",\n    \"template\": null,\n    \"textarea\": null,\n    \"tfoot\": \"tr\",\n    \"thead\": \"tr\",\n    \"tr\": \"td\",\n    \"ul\": \"li\",\n    \"video\": \"track\",\n\n    // void elements\n    \"area\": null,\n    \"base\": null,\n    \"br\": null,\n    \"col\": null,\n    \"embed\": null,\n    \"hr\": null,\n    \"img\": null,\n    \"input\": null,\n    \"link\": null,\n    \"meta\": null,\n    \"param\": null,\n    \"source\": null,\n    \"track\": null,\n    \"wbr\": null,\n\n    // default for all other parents\n    \"*\": \"slot\",\n  },\n};\n", "import { config } from \"../config.ts\";\nimport type { AhxErrorMap, AhxEventMap, EventType } from \"../types.ts\";\n\nfunction dispatch<T>(\n  target: EventTarget | undefined | null,\n  type: EventType,\n  detail?: T,\n  cancelable = true,\n): boolean {\n  if (target !== null) {\n    const event = new CustomEvent(type, {\n      bubbles: !!target,\n      cancelable,\n      detail,\n    });\n\n    if (config.enableDebugEvent) {\n      dispatchEvent(\n        new CustomEvent(config.prefix, {\n          bubbles: false,\n          cancelable: false,\n          detail: {\n            type: event.type,\n            target,\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            detail: event.detail,\n          },\n        }),\n      );\n    }\n\n    return target && \"dispatchEvent\" in target\n      ? target.dispatchEvent(event)\n      : dispatchEvent(event);\n  }\n  return false;\n}\n\nexport function dispatchOneShot<E extends keyof AhxEventMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail?: AhxEventMap[E][0],\n): void {\n  dispatch(target, `${config.prefix}:${name}`, detail, false);\n}\n\nexport function dispatchBefore<E extends keyof AhxEventMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail: AhxEventMap[E][0],\n): boolean {\n  // @ts-ignore to aid logging\n  detail._before = true;\n\n  const permitted = dispatch(target, `${config.prefix}:${name}`, detail);\n\n  // @ts-ignore to aid logging\n  delete detail._before;\n\n  if (!permitted) {\n    dispatch(target, `${config.prefix}:${name}:veto`, detail, false);\n  }\n\n  return permitted;\n}\n\nexport function dispatchAfter<E extends keyof AhxEventMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail?: AhxEventMap[E][1],\n): void {\n  // @ts-ignore to aid logging\n  detail._after = true;\n\n  dispatch(target, `${config.prefix}:${name}:done`, detail, false);\n\n  // @ts-ignore to aid logging\n  delete detail._after;\n}\n\nexport function dispatchError<E extends keyof AhxErrorMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail?: AhxErrorMap[E],\n): void {\n  dispatch(target, `${config.prefix}:${name}:error`, {\n    error: name,\n    ...detail,\n  }, false);\n}\n", "import { config } from \"../config.ts\";\nimport type {\n  AhxAttributeName,\n  AhxCSSPropertyName,\n  AhxHeaderName,\n  ControlPropName,\n  HeaderName,\n} from \"../types.ts\";\n\nexport function getAhxCSSPropertyNames(\n  rule: CSSStyleRule,\n): Set<AhxCSSPropertyName> {\n  const names = new Set<AhxCSSPropertyName>();\n  for (const name of rule.style) {\n    if (isAhxCSSPropertyName(name)) {\n      names.add(name);\n    }\n  }\n  return names;\n}\n\nexport function hasAhxAttributes(elt: Element): boolean {\n  for (const attr of elt.attributes) {\n    if (isAhxAttributeName(attr.name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isAhxCSSPropertyName(name: string): name is AhxCSSPropertyName {\n  return name.startsWith(`--${config.prefix}-`);\n}\n\nexport function isAhxAttributeName(name: string): name is AhxAttributeName {\n  return name.startsWith(`${config.prefix}-`);\n}\n\nexport function isAhxHeaderName(name: string): name is AhxHeaderName {\n  return name.startsWith(`${config.prefix}-`);\n}\n\nexport function asAhxCSSPropertyName(\n  name: ControlPropName | AhxCSSPropertyName | AhxAttributeName,\n): AhxCSSPropertyName {\n  return isAhxCSSPropertyName(name)\n    ? name\n    : isAhxAttributeName(name)\n    ? `--${name}`\n    : `--${config.prefix}-${name}`;\n}\n\nexport function asAhxAttributeName(\n  name: ControlPropName | AhxAttributeName | AhxCSSPropertyName,\n): AhxAttributeName {\n  return isAhxAttributeName(name)\n    ? name\n    : isAhxCSSPropertyName(name)\n    ? name.substring(2) as AhxAttributeName\n    : `${config.prefix}-${name}`;\n}\n\nexport function asAhxHeaderName(name: HeaderName | AhxHeaderName) {\n  return isAhxHeaderName(name) ? name : `${config.prefix}-${name}`;\n}\n", "import { getInternal, hasInternal, setInternal } from \"./internal.ts\";\nimport type { Owner } from \"../types.ts\";\n\nexport function getOwner(thing: CSSRule | StyleSheet | Element) {\n  if (hasInternal(thing, \"owner\")) {\n    return getInternal(thing, \"owner\");\n  }\n\n  if (thing instanceof StyleSheet) {\n    return getInternal(thing, \"owner\") ?? thing.href ?? undefined;\n  }\n\n  if (thing instanceof CSSRule && thing.parentStyleSheet) {\n    return getOwner(thing.parentStyleSheet);\n  }\n\n  if (thing instanceof Element && thing.parentElement) {\n    return getOwner(thing.parentElement);\n  }\n}\n\nexport function setOwner(thing: CSSRule | StyleSheet | Element, owner: Owner) {\n  // TODO: dispatch ahx:setOwner event?\n  if (owner !== getOwner(thing)) {\n    setInternal(thing, \"owner\", owner);\n  }\n}\n", "import { asAhxCSSPropertyName } from \"./util/names.ts\";\nimport type {\n  AhxAttributeName,\n  AhxCSSPropertyName,\n  ControlPropName,\n  ValueType,\n} from \"./types.ts\";\n\nexport function parseCssValue(\n  prop: ControlPropName | AhxCSSPropertyName | AhxAttributeName,\n  rule: CSSStyleRule,\n  elt?: Element,\n  expect: ValueType = \"tokens\",\n): string[] {\n  prop = asAhxCSSPropertyName(prop);\n\n  let value: string | undefined = rule.style.getPropertyValue(prop)?.trim();\n\n  if (value) {\n    // match: attr(<name> <type?>)\n    const isAttr = /^attr\\(([^\\)\\s,]+)(?:\\s+([^\\)\\s,]+))?\\)$/.exec(value);\n    if (isAttr) {\n      if (!elt) {\n        return [value];\n      }\n      value = elt.getAttribute(isAttr[1]) ?? undefined;\n      if (value && isAttr[2] === \"url\") {\n        value = parseURL(value, elt.baseURI);\n      }\n      return value ? [value] : [];\n    } else {\n      // match: --prop(<name> <type?>)\n      const isProp = /^--prop\\(([^\\)\\s,]+)(?:\\s+([^\\)\\s,]+))?\\)$/.exec(value);\n      if (isProp) {\n        if (!elt) {\n          return [value];\n        }\n        value = undefined;\n        const propValue = elt[isProp[1] as keyof Element];\n        if (isProp[2] === \"url\" && typeof propValue === \"string\") {\n          value = parseURL(propValue, elt.baseURI);\n        } else if (\n          typeof propValue === \"string\" || typeof propValue === \"number\" ||\n          typeof propValue === \"boolean\"\n        ) {\n          value = String(propValue);\n        }\n        return value ? [value] : [];\n      }\n    }\n\n    // match: url(<url?>) ...\n    const isURL = /^url\\(([^\\)]*)\\)(?:\\s+url\\(([^\\)]*)\\))*$/.exec(value);\n    if (isURL) {\n      const [, ...values] = isURL;\n      const baseURL = rule.parentStyleSheet?.href ??\n        rule.style.parentRule?.parentStyleSheet?.href ??\n        elt?.baseURI;\n\n      return values.flatMap((value) => {\n        const url = value ? parseURL(parseQuoted(value), baseURL) : undefined;\n        return url ? [url] : [];\n      });\n    }\n\n    value = parseQuoted(value);\n  }\n\n  return value\n    ? (expect === \"tokens\" ? value.split(/\\s+/).map(parseQuoted) : [value])\n    : [];\n\n  function parseURL(value: string, baseURL?: string) {\n    try {\n      return new URL(value, baseURL).href;\n    } catch (e) {\n      console.error(e, value, baseURL);\n    }\n  }\n}\n\nfunction parseQuoted(value: string): string {\n  // match: \"<string?>\" or '<string?>'\n  const isQuoted = /^\\\"([^\\\"]*)\\\"$/.exec(value) ??\n    /^\\'([^\\']*)\\'$/.exec(value);\n  if (isQuoted) {\n    return isQuoted[1];\n  }\n  return value;\n}\n", "import { asAhxAttributeName } from \"./util/names.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\nimport type {\n  AhxAttributeName,\n  AhxCSSPropertyName,\n  ControlPropName,\n  ValueType,\n} from \"./types.ts\";\n\nexport function parseAttrValue(\n  prop: ControlPropName | AhxAttributeName | AhxCSSPropertyName,\n  control: Element,\n  expect: ValueType = \"tokens\",\n): string[] {\n  prop = asAhxAttributeName(prop);\n  const value = control.getAttribute(prop) ?? undefined;\n  return value ? (expect === \"tokens\" ? value.split(/\\s+/) : [value]) : [];\n}\n\nexport function parseAttrOrCssValue(\n  prop: ControlPropName | AhxAttributeName | AhxCSSPropertyName,\n  control: Element | CSSStyleRule,\n  expect: ValueType = \"tokens\",\n): string[] {\n  if (control instanceof Element) {\n    return parseAttrValue(prop, control, expect);\n  } else {\n    return parseCssValue(prop, control, undefined, expect);\n  }\n}\n", "import type { ControlDecl, TriggerSpec } from \"./types.ts\";\nimport { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\n\nexport function parseTriggers(\n  control: ControlDecl,\n): TriggerSpec[] {\n  const [rawValue] = parseAttrOrCssValue(\"trigger\", control, \"whole\");\n  const triggerSpecs: TriggerSpec[] = [];\n\n  if (rawValue) {\n    const triggerValues = rawValue.split(/\\s*,\\s*/);\n\n    for (const triggerValue of triggerValues) {\n      const [trigger, ...modifiers] = triggerValue.split(/\\s+/);\n\n      if (trigger) {\n        const triggerSpec: TriggerSpec = { eventType: trigger };\n\n        for (const modifier of modifiers) {\n          switch (modifier) {\n            // case \"changed\":\n            case \"once\":\n              triggerSpec[modifier] = true;\n              break;\n          }\n        }\n\n        triggerSpecs.push(triggerSpec);\n      }\n    }\n  }\n\n  return triggerSpecs;\n}\n", "import { config } from \"./config.ts\";\nimport { asAhxCSSPropertyName, getAhxCSSPropertyNames } from \"./util/names.ts\";\nimport { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport type { ActionSpec, ControlDecl } from \"./types.ts\";\n\nexport function parseActions(control: ControlDecl): ActionSpec[] {\n  const actionSpecs: ActionSpec[] = [];\n\n  for (const method of config.httpMethods) {\n    const [url] = parseAttrOrCssValue(method, control);\n    if (url) {\n      actionSpecs.push({\n        type: \"request\",\n        method,\n        url: parseURL(url, control),\n      });\n    }\n  }\n\n  if (control instanceof CSSStyleRule) {\n    if (getAhxCSSPropertyNames(control).has(asAhxCSSPropertyName(\"harvest\"))) {\n      actionSpecs.push({\n        type: \"harvest\",\n      });\n    }\n  }\n\n  return actionSpecs;\n}\n\nfunction parseURL(url: string, control: ControlDecl): URL | undefined {\n  const baseURL = control instanceof Element ? control.baseURI : undefined;\n  try {\n    return new URL(url, baseURL);\n  } catch {\n    return undefined;\n  }\n}\n", "export function parseInterval(str?: string): number | undefined {\n  if (str == undefined) {\n    return undefined;\n  }\n  if (str.slice(-2) == \"ms\") {\n    return parseFloat(str.slice(0, -2)) || undefined;\n  }\n  if (str.slice(-1) == \"s\") {\n    return (parseFloat(str.slice(0, -1)) * 1000) || undefined;\n  }\n  if (str.slice(-1) == \"m\") {\n    return (parseFloat(str.slice(0, -1)) * 1000 * 60) || undefined;\n  }\n  return parseFloat(str) || undefined;\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { parseInterval } from \"./parse_interval.ts\";\nimport type { ControlDecl, SwapSpec, SwapStyle } from \"./types.ts\";\n\nexport function parseSwap(control: ControlDecl) {\n  const tokens = parseAttrOrCssValue(\"swap\", control, \"tokens\");\n\n  const swapSpec: SwapSpec = {};\n\n  if (tokens?.length) {\n    swapSpec.swapStyle = tokens.shift()?.toLowerCase() as SwapStyle;\n\n    if (swapSpec.swapStyle === \"attr\" || swapSpec.swapStyle === \"input\") {\n      swapSpec.itemName = tokens.shift();\n    }\n\n    for (const token of tokens) {\n      const [modifier, value] = token.split(\":\");\n      switch (modifier) {\n        case \"swap\":\n        case \"delay\":\n          swapSpec.delay = parseInterval(value);\n          break;\n        case \"join\":\n          swapSpec.merge = \"join\";\n          break;\n        case \"append\":\n          swapSpec.merge = \"append\";\n          break;\n      }\n    }\n  }\n\n  return swapSpec;\n}\n", "export function querySelectorExt(\n  elt: Element,\n  query?: string,\n): Element | undefined {\n  return _query(elt, query, false);\n}\n\nexport function querySelectorAllExt(\n  elt: Element,\n  query?: string,\n): Iterable<Element> {\n  return _query(elt, query, true);\n}\n\nfunction _query(\n  elt: Element,\n  query: string | undefined,\n  all: true,\n): Iterable<Element>;\nfunction _query(\n  elt: Element,\n  query: string | undefined,\n  all: false,\n): Element | undefined;\nfunction _query(\n  elt: Element,\n  query: string | undefined,\n  all: boolean,\n): Iterable<Element> | Element | undefined {\n  if (!query) {\n    return single();\n  }\n\n  const [axis, selector] = splitQuery(query);\n\n  switch (axis) {\n    case \"this\":\n      return single(elt);\n    case \"closest\":\n      return single(elt.closest(selector));\n    case \"find\":\n      return all\n        ? elt.querySelectorAll(selector)\n        : elt.querySelector(selector) ?? undefined;\n    case \"next\":\n      return single(next(elt, selector));\n    case \"previous\":\n      return single(previous(elt, selector));\n    case \"body\":\n      return single(elt.ownerDocument.body);\n    case \"document\":\n    case \"window\":\n      // for compatibility with htmx syntax, but we do not support\n      // returning the document or window\n      return single();\n    default:\n      return all\n        ? elt.ownerDocument.querySelectorAll(query)\n        : elt.ownerDocument.querySelector(query) ?? undefined;\n  }\n\n  function single(found?: Element | null) {\n    return all ? (found ? [found] : []) : (found ?? undefined);\n  }\n}\n\nfunction splitQuery(query: string) {\n  const spaceIndex = query.indexOf(\" \");\n  if (spaceIndex === -1) {\n    return [query, \"\"];\n  } else {\n    return [query.substring(0, spaceIndex), query.substring(spaceIndex + 1)];\n  }\n}\n\nfunction next(start: Element, selector: string) {\n  for (const elt of start.ownerDocument.querySelectorAll(selector)) {\n    if (\n      elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING\n    ) {\n      return elt;\n    }\n  }\n}\n\nfunction previous(start: Element, selector: string) {\n  const results = start.ownerDocument.querySelectorAll(selector);\n  for (let i = results.length - 1; i >= 0; i--) {\n    const elt = results[i];\n    if (\n      elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING\n    ) {\n      return elt;\n    }\n  }\n}\n", "/**\n * @template T\n * @this {ReadableStream<T>}\n */\nasync function* readableStreamIterator() {\n  const reader = this.getReader();\n  try {\n    let done, value;\n    do {\n      ({ done, value } = await reader.read());\n      if (value !== undefined) {\n        yield value;\n      }\n    } while (!done);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nReadableStream.prototype[Symbol.asyncIterator] ??= readableStreamIterator;\n", "/**\n * Parse a stream of HTML into Elements.\n *\n * Only emits child elements of the body once the parser moves\n * onto the next child element. All head elements are ignored,\n * as are non-element child nodes of the body (eg. comments, character data).\n *\n * The stream can be a series of individual HTML elements, not necessarily\n * enclosed within `<html>`/`<body>` tags, but proceeded by `<!DOCTYPE html>`,\n * and this would be a perfectly valid HTML5 document (as far as the parser\n * is concerned at least).\n *\n * @example\n * response.body\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new HTMLBodyElementParserStream(document));\n *\n * @extends {TransformStream<string, Element>}\n */\nexport class HTMLBodyElementParserStream extends TransformStream {\n  /**\n   * @param {Document} document will own the emitted elements\n   * @param {boolean} [template] extract content out of a template element\n   */\n  constructor(document, template) {\n    /** @type {Document} */\n    let parser;\n\n    /** @type {ParentNode} */\n    let container;\n\n    super({\n      start() {\n        // Create a temporary empty document to perform the parsing\n        parser = document.implementation.createHTMLDocument();\n      },\n\n      transform(chunk, controller) {\n        // Write each chunk into the document\n        parser.write(chunk);\n\n        // Determine the container once the first element is written\n        if (!container && parser.body?.childElementCount > 0) {\n          const element = parser.body.children[0];\n          if (template && element instanceof HTMLTemplateElement) {\n            // Set the container to the DocumentFragment in the template\n            container = element.content;\n          } else {\n            // Set the container to the body\n            container = parser.body;\n          }\n        }\n\n        // Once we have more than one element in the body we\n        // assume that all but the last element are complete\n        while (container?.childElementCount > 1) {\n          // Get the first element from the body\n          const element = container.children[0];\n\n          // Transfer the element ownership to the target document,\n          // this will also remove it from the body of the parser document\n          document.adoptNode(element);\n\n          // Emit the Element from the transformer\n          controller.enqueue(element);\n        }\n      },\n\n      flush(controller) {\n        // Transfer and emit any remaining elements from the body\n        for (const element of [...container?.children ?? []]) {\n          document.adoptNode(element);\n          controller.enqueue(element);\n        }\n        // Close the document for writing\n        parser.close();\n        parser = undefined;\n        container = undefined;\n      },\n    });\n  }\n}\n", "import { objectsWithInternal } from \"./internal.ts\";\n\nexport function findSlots(query: string, root: ParentNode): Element[] {\n  const [name, selector] = splitQuery(query);\n  let slots: Element[] = [];\n\n  for (const [thing, slotNames] of objectsWithInternal(\"slotName\")) {\n    if (slotNames.has(name)) {\n      if (thing instanceof Element) {\n        slots.push(thing);\n      } else if (thing instanceof CSSStyleRule) {\n        slots.push(...root.querySelectorAll(thing.selectorText));\n      }\n    }\n  }\n\n  if (selector) {\n    slots = slots.filter((slot) => slot.matches(selector));\n  }\n\n  return slots;\n}\n\nfunction splitQuery(query: string) {\n  const spaceIndex = query.indexOf(\" \");\n  if (spaceIndex === -1) {\n    return [query, \"\"];\n  } else {\n    return [query.substring(0, spaceIndex), query.substring(spaceIndex + 1)];\n  }\n}\n", "import \"../ext/polyfill/ReadableStream_asyncIterator.js\";\n\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { SwapHtmlDetail, SwapHtmlProps, SwapHtmlStyle } from \"./types.ts\";\nimport { HTMLBodyElementParserStream } from \"../ext/HTMLBodyElementParserStream.js\";\nimport { setOwner } from \"./util/owner.ts\";\nimport { config } from \"./config.ts\";\nimport { cloneInternal } from \"./util/internal.ts\";\nimport { parseAttrValue } from \"./parse_attr_value.ts\";\nimport { findSlots } from \"./util/slots.ts\";\n\nexport async function swapHtml(props: SwapHtmlProps) {\n  const { response, target } = props;\n  const document = target.ownerDocument;\n\n  if (\n    response?.ok &&\n    response.headers.get(\"Content-Type\")?.startsWith(\"text/html\") &&\n    response.body\n  ) {\n    let index = 0;\n    let previous: Element | undefined;\n    let replacePrevious = false;\n\n    const elements = response.body\n      .pipeThrough(new TextDecoderStream())\n      .pipeThrough(new HTMLBodyElementParserStream(document, true));\n\n    for await (let element of elements) {\n      switch (element.localName) {\n        case `${config.prefix}-replace-previous`:\n          replacePrevious = true;\n          continue;\n        case `${config.prefix}-flush`:\n          continue;\n      }\n\n      let swapStyle = props.swapStyle ?? \"none\";\n      let targets = [target];\n\n      const [slot] = parseAttrValue(\"slot\", element, \"whole\");\n\n      if (slot) {\n        const slotTargets = findSlots(slot, document);\n\n        if (slotTargets.length) {\n          targets = slotTargets;\n          swapStyle = \"inner\";\n        } else {\n          swapStyle = \"none\";\n        }\n      }\n\n      const templateElement = targets.length ? element : undefined;\n\n      for (const target of targets) {\n        if (templateElement) {\n          element = templateElement.cloneNode(true) as typeof element;\n        }\n\n        const detail: SwapHtmlDetail = {\n          ...props,\n          swapStyle,\n          target,\n          element,\n          previous,\n          index,\n          slot,\n        };\n\n        if (dispatchBefore(target, \"swap\", detail)) {\n          const { target, element, controlOwner, swapStyle, slot } = detail;\n\n          if (controlOwner) {\n            setOwner(element, controlOwner);\n          }\n\n          if (slot || !previous) {\n            swapHandlers[swapStyle]?.(target, element);\n          } else if (previous && replacePrevious) {\n            previous.replaceWith(element);\n          } else {\n            previous.after(element);\n          }\n\n          if (!slot) {\n            previous = element;\n          }\n\n          dispatchAfter(target, \"swap\", detail);\n        }\n      }\n\n      index++;\n    }\n  }\n  // TODO: trigger events for non-ok response and non-html content\n}\n\ntype SwapHandler = (\n  target: Element,\n  element: Element,\n) => void;\n\nconst swapAdjacent =\n  (pos: InsertPosition): SwapHandler => (target, element) => {\n    target.insertAdjacentElement(pos, element);\n  };\n\nconst swapHandlers: Record<SwapHtmlStyle, SwapHandler> = {\n  none() {\n    // no-op\n  },\n  inner(target, element) {\n    target.replaceChildren(element);\n  },\n  outer(target, element) {\n    const pseudoPrefix = `${config.prefix}-pseudo`;\n\n    for (const cls of target.classList) {\n      if (cls.startsWith(pseudoPrefix)) {\n        element.classList.add(cls);\n      }\n    }\n\n    cloneInternal(target, element);\n\n    target.replaceWith(element);\n  },\n  beforebegin: swapAdjacent(\"beforebegin\"),\n  afterbegin: swapAdjacent(\"afterbegin\"),\n  beforeend: swapAdjacent(\"beforeend\"),\n  afterend: swapAdjacent(\"afterend\"),\n};\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { SwapTextDetail, SwapTextProps } from \"./types.ts\";\n\nexport function swapAttr(props: SwapTextProps) {\n  const { target, itemName, merge } = props;\n\n  const detail: SwapTextDetail = {\n    ...props,\n  };\n\n  detail.oldValue = target.getAttribute(itemName) ?? undefined;\n\n  if (merge === \"join\" && detail.oldValue && detail.value) {\n    detail.value = join(detail.oldValue, detail.value);\n  }\n\n  if (dispatchBefore(target, \"swap\", detail)) {\n    const { target, itemName, value } = detail;\n\n    if (itemName && value !== undefined) {\n      target.setAttribute(itemName, value);\n    }\n\n    dispatchAfter(target, \"swap\", detail);\n  }\n}\n\nfunction join(oldValue: string, newValue: string) {\n  const sep = \" \";\n  const values = new Set(`${oldValue}${sep}${newValue}`.split(sep));\n  values.delete(\"\");\n  return [...values].join(sep);\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { getInternal } from \"./util/internal.ts\";\nimport type { SwapDetail, SwapTextProps } from \"./types.ts\";\n\nexport function swapInput(props: SwapTextProps) {\n  const { target, itemName, merge, value } = props;\n\n  if (!itemName || value === undefined) {\n    // TODO: consider dispatching an error event (at least for no itemName)\n    return;\n  }\n\n  const detail: SwapDetail = {\n    ...props,\n  };\n\n  if (target instanceof HTMLFormElement) {\n    detail.input = target.elements.namedItem(itemName) ?? undefined;\n\n    switch (merge) {\n      case \"append\":\n        detail.input = createInput(itemName, target.ownerDocument);\n        break;\n\n      default:\n        if (!detail.input) {\n          detail.input = createInput(itemName, target.ownerDocument);\n        } else if (\"value\" in detail.input) {\n          detail.oldValue = detail.input.value;\n        }\n        break;\n    }\n  } else {\n    detail.formData = getInternal(target, \"formData\", () => new FormData());\n    const oldValue = detail.formData.get(itemName);\n    if (typeof oldValue === \"string\") {\n      detail.oldValue = oldValue;\n    }\n  }\n\n  if (merge === \"join\") {\n    detail.value = join(detail.oldValue, detail.value);\n  }\n\n  if (dispatchBefore(target, \"swap\", detail)) {\n    const { target, input, itemName, merge, formData, value } = detail;\n\n    if (itemName && value !== undefined) {\n      if (input && \"value\" in input) {\n        input.value = value;\n        if (input instanceof Element && !input.parentElement) {\n          target.insertAdjacentElement(\"beforeend\", input);\n        }\n      } else if (formData) {\n        if (merge === \"append\") {\n          formData.append(itemName, value);\n        } else {\n          formData.set(itemName, value);\n        }\n      }\n    }\n\n    dispatchAfter(target, \"swap\", detail);\n  }\n}\n\nfunction createInput(name: string, document: Document) {\n  const input = document.createElement(\"input\");\n  input.type = \"hidden\";\n  input.name = name;\n  return input;\n}\n\nfunction join(oldValue = \"\", newValue = \"\") {\n  const sep = \" \";\n  const values = new Set(`${oldValue}${sep}${newValue}`.split(sep));\n  values.delete(\"\");\n  return [...values].join(sep);\n}\n", "import { swapAttr } from \"./swap_attr.ts\";\nimport { swapInput } from \"./swap_input.ts\";\nimport type { SwapTextProps } from \"./types.ts\";\n\nexport function swapText(props: SwapTextProps) {\n  const { swapStyle } = props;\n\n  switch (swapStyle) {\n    case \"input\":\n      return swapInput(props);\n    case \"attr\":\n      return swapAttr(props);\n  }\n}\n", "import { swapHtml } from \"./swap_html.ts\";\nimport { swapText } from \"./swap_text.ts\";\nimport type { SwapProps } from \"./types.ts\";\n\nexport async function handleSwap(props: SwapProps) {\n  const { swapStyle, response, itemName } = props;\n  let { value } = props;\n\n  switch (swapStyle) {\n    case \"input\":\n    case \"attr\": {\n      if (!itemName) {\n        // TODO: consider dispatching an error\n        return;\n      }\n\n      if (value === undefined && response) {\n        value = await response.text();\n        // TODO: handle errors\n      }\n\n      return swapText({\n        ...props,\n        swapStyle,\n        itemName,\n        value,\n      });\n    }\n\n    default:\n      if (isHtmlResponse(response)) {\n        return swapHtml({\n          ...props,\n          swapStyle: swapStyle ?? \"none\",\n          response,\n        });\n      }\n  }\n}\n\nfunction isHtmlResponse(response?: Response): response is Response {\n  return !!response?.headers.get(\"Content-Type\")?.startsWith(\"text/html\") &&\n    !!response.body;\n}\n", "import {\n  dispatchAfter,\n  dispatchBefore,\n  dispatchError,\n} from \"./util/dispatch.ts\";\nimport { handleSwap } from \"./handle_swap.ts\";\nimport type { ActionDetail, ActionRequestSpec } from \"./types.ts\";\nimport { asAhxHeaderName } from \"./util/names.ts\";\n\nexport async function handleRequest(props: ActionDetail) {\n  const { source, action, target, swap, controlOwner, targetOwner } = props;\n\n  if (action.type !== \"request\") {\n    return;\n  }\n\n  const request = prepareRequest({ ...props, action });\n\n  if (!request) {\n    return;\n  }\n\n  const detail = { request };\n\n  if (dispatchBefore(source, \"request\", detail)) {\n    const { request } = detail;\n\n    try {\n      const response = await fetch(request);\n\n      dispatchAfter(source, \"request\", { request, response });\n\n      if (response.headers.has(asAhxHeaderName(\"refresh\"))) {\n        const detail = {\n          ...props,\n          request,\n          response,\n          refresh: true,\n          url: new URL(location.href),\n        };\n        if (dispatchBefore(source, \"navigate\", detail)) {\n          location.reload();\n          return;\n        }\n      }\n\n      await handleSwap({\n        ...swap,\n        target,\n        response,\n        controlOwner,\n        targetOwner,\n      });\n    } catch (error) {\n      dispatchAfter(source, \"request\", { request, error });\n    }\n  }\n}\n\nfunction prepareRequest(detail: ActionDetail & { action: ActionRequestSpec }) {\n  const { action, formData, source } = detail;\n\n  if (!action.url) {\n    dispatchError(source, \"invalidRequest\", {\n      action,\n      reason: \"Missing URL\",\n    });\n    return;\n  }\n\n  const url = new URL(action.url);\n\n  const headers = new Headers();\n\n  const init: RequestInit = {\n    method: action.method.toUpperCase(),\n    headers,\n  };\n\n  headers.set(\"Accept\", \"text/html,application/xhtml+xml,text/plain;q=0.9\");\n  headers.set(asAhxHeaderName(\"request\"), \"true\");\n  headers.set(\n    asAhxHeaderName(\"current-url\"),\n    source.ownerDocument.location.href,\n  );\n\n  if (formData) {\n    switch (init.method) {\n      case \"GET\":\n      case \"HEAD\":\n      case \"DELETE\":\n        for (const [key, value] of formData) {\n          if (typeof value === \"string\") {\n            url.searchParams.append(key, value);\n          }\n        }\n        break;\n\n      case \"PUT\":\n      case \"POST\":\n      case \"PATCH\":\n        if (containsFile(formData)) {\n          init.body = formData;\n          headers.set(\"Content-Type\", \"multipart/form-data\");\n        } else {\n          // deno-lint-ignore no-explicit-any\n          init.body = new URLSearchParams(formData as any);\n          headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        }\n    }\n  }\n\n  return new Request(url, init);\n}\n\nfunction containsFile(formData: FormData): boolean {\n  for (const value of formData.values()) {\n    if (value instanceof File) {\n      return true;\n    }\n  }\n  return false;\n}\n", "import type { ActionDetail, HarvestDetail } from \"./types.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { handleSwap } from \"./handle_swap.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\n\nexport async function handleHarvest(props: ActionDetail & { target: Element }) {\n  const {\n    event,\n    source,\n    action,\n    target,\n    swap,\n    control,\n    controlOwner,\n    targetOwner,\n  } = props;\n\n  if (!(control instanceof CSSStyleRule) || action.type !== \"harvest\") {\n    return;\n  }\n\n  const [newValue] = parseCssValue(\"harvest\", control, source);\n\n  if (newValue === undefined) {\n    return;\n  }\n\n  const oldValue = getOldValue(event);\n\n  const detail: HarvestDetail = {\n    source,\n    oldValue,\n    newValue,\n    control,\n    targetOwner,\n    controlOwner,\n  };\n\n  if (dispatchBefore(source, \"harvest\", detail)) {\n    await handleSwap({\n      ...swap,\n      target,\n      value: detail.newValue,\n    });\n\n    dispatchAfter(source, \"harvest\", detail);\n  }\n}\n\nfunction getOldValue(event?: Event): string | undefined {\n  if (event instanceof CustomEvent && \"oldValue\" in event.detail) {\n    return event.detail.oldValue;\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { querySelectorExt } from \"./util/query_selector.ts\";\nimport { handleRequest } from \"./handle_request.ts\";\nimport { getInternal, hasInternal } from \"./util/internal.ts\";\nimport type { ActionDetail } from \"./types.ts\";\nimport { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { handleHarvest } from \"./handle_harvest.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\n\nexport async function handleAction(detail: ActionDetail) {\n  const { source, control, action } = detail;\n\n  const [query] = parseAttrOrCssValue(\"include\", control, \"whole\");\n  const include = querySelectorExt(source, query);\n\n  detail.formData = include ? getFormData(include) : undefined;\n\n  if (\n    action.type === \"request\" && control instanceof CSSStyleRule &&\n    action.url === undefined\n  ) {\n    const [url] = parseCssValue(action.method, control, source);\n    if (url) {\n      detail.action = {\n        ...action,\n        url: new URL(url, source.baseURI),\n      };\n    }\n  }\n\n  if (dispatchBefore(source, \"action\", detail)) {\n    switch (detail.action.type) {\n      case \"request\":\n        await handleRequest(detail);\n        break;\n\n      case \"harvest\":\n        await handleHarvest(detail);\n        break;\n    }\n\n    dispatchAfter(source, \"action\", detail);\n  }\n}\n\nfunction getFormData(elt: Element): FormData | undefined {\n  if (hasInternal(elt, \"formData\")) {\n    return getInternal(elt, \"formData\");\n  }\n\n  if (elt instanceof HTMLFormElement) {\n    return new FormData(elt);\n  }\n}\n", "import type { TriggerDetail } from \"../types.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./dispatch.ts\";\n\nconst actionQueue = new Set<TriggerDetail>();\n\nexport function enqueueAction(detail: TriggerDetail) {\n  if (dispatchBefore(detail.source, \"queue\", detail)) {\n    actionQueue.add(detail);\n  }\n}\n\nexport function dequeueAction(detail: TriggerDetail) {\n  actionQueue.delete(detail);\n  dispatchAfter(detail.source, \"queue\", detail);\n}\n\nexport function queue(): Iterable<TriggerDetail> {\n  return actionQueue.values();\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { getInternal } from \"./util/internal.ts\";\nimport {\n  dispatchAfter,\n  dispatchBefore,\n  dispatchError,\n} from \"./util/dispatch.ts\";\nimport type { ActionDetail, TriggerDetail } from \"./types.ts\";\nimport { handleAction } from \"./handle_action.ts\";\nimport { enqueueAction } from \"./util/queue.ts\";\n\nexport function handleTrigger(detail: TriggerDetail) {\n  const { control, trigger, source } = detail;\n\n  if (isDenied(source)) {\n    dispatchError(source, \"triggerDenied\", detail);\n    return;\n  }\n\n  if (\n    trigger?.once &&\n    getInternal(source, `triggered:${trigger.eventType}`)?.has(control)\n  ) {\n    return;\n  }\n\n  if (trigger?.changed) {\n    // TODO: return if value hasn't changed\n  }\n\n  if (dispatchBefore(source, \"trigger\", detail)) {\n    if (trigger?.once) {\n      getInternal(source, `triggered:${trigger.eventType}`, () => new WeakSet())\n        .add(control);\n    }\n\n    // TODO: throttle\n\n    if (trigger?.throttle) {\n      // TODO\n    } else if (trigger?.delay) {\n      setTimeout(doAction, trigger.delay);\n    } else {\n      setTimeout(doAction, 0);\n    }\n\n    dispatchAfter(source, \"trigger\", detail);\n  }\n\n  function doAction() {\n    if (hasTarget(detail)) {\n      handleAction(detail);\n    } else {\n      enqueueAction(detail);\n    }\n  }\n}\n\nexport function isDenied(elt: Element) {\n  // TODO: Should get calculated CSS value\n  const [deny] = parseAttrOrCssValue(\"deny-trigger\", elt);\n  return deny === \"true\";\n}\n\nfunction hasTarget(detail: TriggerDetail): detail is ActionDetail {\n  return detail.target instanceof Element;\n}\n", "import { config } from \"../config.ts\";\n\nconst AHX_EVENTS = new Set([\"load\", \"watch\"]);\n\nexport function toDOMEventType(type: string) {\n  if (AHX_EVENTS.has(type)) {\n    return `${config.prefix}:${type}`;\n  }\n  return type;\n}\n\nexport function fromDOMEventType(type: string) {\n  const prefix = `${config.prefix}:`;\n  if (type.startsWith(prefix)) {\n    return type.substring(prefix.length);\n  }\n  return type;\n}\n", "import type { RuleId } from \"../types.ts\";\nimport { getInternal, objectsWithInternal } from \"./internal.ts\";\nimport { asAhxCSSPropertyName } from \"./names.ts\";\n\nexport function isRuleEnabled(rule: CSSStyleRule): boolean {\n  return !!rule.parentStyleSheet && !rule.parentStyleSheet.disabled;\n}\n\n// The following are experimental...\n\nexport function isRuleApplied(rule: CSSStyleRule, elt: Element): boolean {\n  const ruleId = getInternal(rule, \"ruleId\");\n  if (ruleId) {\n    const ruleIdProp = asAhxCSSPropertyName(`rule-${ruleId}`);\n    const style = getComputedStyle(elt);\n    if (style.getPropertyValue(ruleIdProp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nlet ruleCount = 0;\n\nexport function getRuleId(rule: CSSStyleRule): RuleId {\n  return getInternal(rule, \"ruleId\", () => `${++ruleCount}`);\n}\n\nexport function getRuleById(ruleId: RuleId): CSSStyleRule | undefined {\n  // TODO: index rules by id\n  for (const [rule, id] of objectsWithInternal(\"ruleId\")) {\n    if (ruleId === id && rule instanceof CSSStyleRule) {\n      return rule;\n    }\n  }\n}\n\nexport function* getAppliedRules(elt: Element): Iterable<CSSStyleRule> {\n  const ruleProp = asAhxCSSPropertyName(\"rule\");\n\n  const style = getComputedStyle(elt);\n\n  const primaryId = style.getPropertyValue(ruleProp);\n\n  if (primaryId) {\n    const primaryRule = getRuleById(primaryId);\n    if (primaryRule) {\n      yield primaryRule;\n    }\n\n    const ruleIdPrefix = asAhxCSSPropertyName(\"rule-\");\n\n    for (const propName of style) {\n      if (propName.startsWith(ruleIdPrefix)) {\n        const secondaryId = style.getPropertyValue(propName);\n        if (secondaryId !== primaryId) {\n          const secondaryRule = getRuleById(secondaryId);\n          if (secondaryRule) {\n            yield secondaryRule;\n          }\n        }\n      }\n    }\n  }\n}\n", "import type { ControlDecl, ControlSpec, EventType } from \"../types.ts\";\nimport { getInternal, objectsWithInternal } from \"./internal.ts\";\nimport { isRuleEnabled } from \"./rules.ts\";\n\nexport function* getControlsFromElements(\n  eventType: EventType,\n  root: Element,\n  recursive: boolean,\n): Iterable<[Element, ControlDecl, ControlSpec]> {\n  const ctlSpec = getInternal(root, `control:${eventType}`);\n\n  if (ctlSpec) {\n    yield [root, root, ctlSpec];\n  }\n\n  if (recursive) {\n    for (const [elt, ctlSpec] of objectsWithInternal(`control:${eventType}`)) {\n      if (\n        elt instanceof Element && root.compareDocumentPosition(elt) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        yield [elt, elt, ctlSpec];\n      }\n    }\n  }\n}\n\nexport function* getControlsFromRules(\n  eventType: EventType,\n  root: Element,\n  recursive: boolean,\n): Iterable<[Element, ControlDecl, ControlSpec]> {\n  for (const [rule, ctlSpec] of objectsWithInternal(`control:${eventType}`)) {\n    if (ctlSpec && rule instanceof CSSStyleRule && isRuleEnabled(rule)) {\n      // ... that match the element\n      if (root.matches(rule.selectorText)) {\n        yield [root, rule, ctlSpec];\n      }\n\n      // ... on all sub-elements that match the selector\n      if (recursive) {\n        for (const elt of root.querySelectorAll(rule.selectorText)) {\n          yield [elt, rule, ctlSpec];\n        }\n      }\n    }\n  }\n}\n\nexport function* getControls(\n  eventType: EventType,\n  root: Element,\n  recursive: boolean,\n): Iterable<[Element, ControlDecl, ControlSpec]> {\n  yield* getControlsFromElements(eventType, root, recursive);\n  yield* getControlsFromRules(eventType, root, recursive);\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport type { ControlDecl } from \"./types.ts\";\nimport { querySelectorExt } from \"./util/query_selector.ts\";\n\nexport function parseTarget(\n  elt: Element,\n  control: ControlDecl,\n): Element | \"await\" {\n  let [targetQuery] = parseAttrOrCssValue(\"target\", control, \"whole\");\n  const hasAwait = /^await\\s+/.test(targetQuery);\n\n  if (hasAwait) {\n    targetQuery = targetQuery.substring(5).trimStart();\n  }\n\n  const target = querySelectorExt(elt, targetQuery);\n\n  if (hasAwait) {\n    return target ?? \"await\";\n  } else {\n    return target ?? elt;\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { handleTrigger } from \"./handle_trigger.ts\";\nimport type { EventType, TriggerDetail } from \"./types.ts\";\nimport { getOwner } from \"./util/owner.ts\";\nimport { fromDOMEventType, toDOMEventType } from \"./util/event.ts\";\nimport { getControls } from \"./util/controls.ts\";\nimport { parseTarget } from \"./parse_target.ts\";\n\nconst eventTypes = new Set<EventType>();\n\nexport function initEventListener(eventType: EventType) {\n  if (!eventTypes.has(eventType)) {\n    const detail = { eventType };\n\n    if (dispatchBefore(undefined, \"addEventType\", detail)) {\n      eventTypes.add(eventType);\n\n      addEventListener(toDOMEventType(eventType), eventListener);\n\n      dispatchAfter(undefined, \"addEventType\", detail);\n    }\n  }\n}\n\nfunction eventListener(event: Event) {\n  for (const detail of getTriggerDetailsForEvent(event)) {\n    handleTrigger(detail);\n  }\n}\n\nfunction* getTriggerDetailsForEvent(\n  event: Event,\n): Iterable<TriggerDetail> {\n  if (event.target instanceof Element) {\n    const controls = getControls(\n      fromDOMEventType(event.type),\n      event.target,\n      isRecursive(event),\n    );\n\n    for (const [source, control, ctlSpec] of controls) {\n      const target = parseTarget(source, control);\n      yield {\n        ...ctlSpec,\n        event,\n        source,\n        sourceOwner: getOwner(source),\n        target,\n        targetOwner: target !== \"await\" ? getOwner(target) : undefined,\n        control,\n        controlOwner: getOwner(control),\n      };\n    }\n  }\n}\n\nfunction isRecursive(event: Event): boolean {\n  return event instanceof CustomEvent && !!event.detail?.recursive;\n}\n", "/**\n * Resolve a given object to the most appropriate element, usually for triggering an event on.\n */\nexport function resolveElement(\n  thing: CSSRule | CSSStyleSheet | Element | null,\n): Element | undefined {\n  if (thing instanceof Element) {\n    return thing;\n  }\n  if (\n    thing && \"ownerNode\" in thing && thing.ownerNode &&\n    thing.ownerNode instanceof Element\n  ) {\n    return thing.ownerNode;\n  }\n  if (thing?.parentStyleSheet) {\n    return resolveElement(thing.parentStyleSheet);\n  }\n  if (thing && \"ownerRule\" in thing) {\n    return resolveElement(thing.ownerRule);\n  }\n}\n", "import { initEventListener } from \"./event_listener.ts\";\nimport type { ControlDetail } from \"./types.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { setInternal } from \"./util/internal.ts\";\n\nexport function processControl(detail: ControlDetail) {\n  const target = resolveElement(detail.control);\n\n  if (dispatchBefore(target, \"processControl\", detail)) {\n    const { control, trigger, action, swap } = detail;\n    const { eventType } = trigger;\n\n    setInternal(control, `control:${eventType}`, { trigger, action, swap });\n\n    initEventListener(eventType);\n\n    dispatchAfter(target, \"processControl\", detail);\n  }\n}\n", "import { parseTriggers } from \"./parse_triggers.ts\";\nimport type { ControlDecl } from \"./types.ts\";\nimport { parseActions } from \"./parse_actions.ts\";\nimport { parseSwap } from \"./parse_swap.ts\";\nimport { processControl } from \"./process_control.ts\";\n\nexport function processControls(control: ControlDecl) {\n  const triggers = parseTriggers(control);\n  const actions = parseActions(control);\n  const swap = parseSwap(control);\n\n  for (const trigger of triggers) {\n    for (const action of actions) {\n      processControl({\n        control,\n        trigger,\n        action,\n        swap,\n      });\n    }\n  }\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport type { ControlDecl } from \"./types.ts\";\nimport { getInternal } from \"./util/internal.ts\";\n\nexport function processSlot(control: ControlDecl) {\n  const slotNames = parseAttrOrCssValue(\"slot-name\", control, \"tokens\");\n  if (slotNames.length) {\n    const names = getInternal(control, \"slotName\", () => new Set());\n    slotNames.forEach((name) => names.add(name));\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { hasAhxAttributes } from \"./util/names.ts\";\nimport { getOwner, setOwner } from \"./util/owner.ts\";\nimport { processControls } from \"./process_controls.ts\";\nimport { processSlot } from \"./process_slot.ts\";\n\nexport function processElement(elt: Element) {\n  if (hasAhxAttributes(elt)) {\n    const detail = {\n      owner: getOwner(elt),\n    };\n\n    if (dispatchBefore(elt, \"processElement\", detail)) {\n      if (detail.owner) {\n        setOwner(elt, detail.owner);\n      }\n\n      processControls(elt);\n      processSlot(elt);\n\n      dispatchAfter(elt, \"processElement\", detail);\n    }\n  }\n}\n", "import { processElement } from \"./process_element.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { config } from \"./config.ts\";\nimport { asAhxAttributeName } from \"./util/names.ts\";\n\nexport function processElements(\n  root: ParentNode,\n) {\n  const selectors = new Set<string>();\n\n  [...config.ahxAttrs, ...config.httpMethods].forEach((attr) => {\n    selectors.add(`[${asAhxAttributeName(attr)}]`);\n  });\n\n  const detail = { selectors };\n\n  if (dispatchBefore(root, \"processElements\", detail)) {\n    const processed = new Set<Node>();\n\n    for (const selector of detail.selectors) {\n      if (\n        !processed.has(root) && root instanceof Element &&\n        root.matches(selector)\n      ) {\n        processed.add(root);\n        processElement(root);\n      }\n      for (const elt of root.querySelectorAll(selector)) {\n        if (!processed.has(elt)) {\n          processed.add(elt);\n          processElement(elt);\n        }\n      }\n    }\n\n    dispatchAfter(root, \"processElements\", detail);\n  }\n}\n", "import { dispatchOneShot } from \"./util/dispatch.ts\";\n\nexport function triggerMutate(elt: Element) {\n  dispatchOneShot(elt, \"mutate\", {});\n}\n", "import { dispatchOneShot } from \"./util/dispatch.ts\";\n\nexport function triggerLoad(elt: Element) {\n  dispatchOneShot(elt, \"load\", { recursive: true });\n}\n", "import { setInternal } from \"./util/internal.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\nimport { dispatchError } from \"./util/dispatch.ts\";\nimport type { AhxCSSPropertyName } from \"./types.ts\";\nimport { asAhxCSSPropertyName } from \"./util/names.ts\";\n\nexport function processGuards(\n  rule: CSSStyleRule,\n  props: Set<AhxCSSPropertyName>,\n) {\n  const prop = asAhxCSSPropertyName(\"deny-trigger\");\n\n  if (props.has(prop)) {\n    const [value] = parseCssValue(prop, rule);\n    if (value === \"true\") {\n      setInternal(rule, \"denyTrigger\", true);\n    } else {\n      rule.style.removeProperty(prop);\n      dispatchError(\n        rule.parentStyleSheet?.ownerNode ?? document,\n        \"invalidCssValue\",\n        {\n          prop,\n          value,\n          rule,\n        },\n      );\n    }\n  }\n\n  return [];\n}\n", "import { config } from \"./config.ts\";\nimport { getInternal, hasInternal, setInternal } from \"./util/internal.ts\";\nimport {\n  dispatchAfter,\n  dispatchBefore,\n  dispatchError,\n} from \"./util/dispatch.ts\";\nimport type { PseudoId, PseudoPlace } from \"./types.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { getOwner, setOwner } from \"./util/owner.ts\";\n\nlet nextPseudoId = 1;\n\nexport function processPseudoElements(\n  rule: CSSStyleRule,\n) {\n  // TODO: better selectorText parsing\n  const before = rule.selectorText.includes(\"::before\");\n  const after = before ? false : rule.selectorText.includes(\"::after\");\n\n  if (before || after) {\n    const pseudoId = getInternal(rule, \"pseudoId\") || nextPseudoId++;\n    const place = before ? \"before\" : \"after\";\n    const parentSelector = rule.selectorText.replace(`::${place}`, \"\");\n\n    for (const elt of document.querySelectorAll(parentSelector)) {\n      // Insert a 'pseudo-element'\n      createPseudoElement(elt, pseudoId, place);\n    }\n\n    return createPseudoRule(rule, pseudoId, place);\n  }\n}\n\nfunction createPseudoElement(\n  elt: Element,\n  pseudoId: PseudoId,\n  place: PseudoPlace,\n) {\n  const pseudoIdClass = `${config.prefix}-pseudo-${pseudoId}`;\n\n  if (!elt.querySelector(`:scope > .${pseudoIdClass}`)) {\n    const parentTag = elt.localName;\n\n    let pseudoTag = config.pseudoChildTags[parentTag];\n\n    if (pseudoTag === null) {\n      dispatchError(elt, \"pseudoElementNotPermitted\", { parentTag });\n      return;\n    }\n\n    if (pseudoTag === undefined) {\n      pseudoTag = config.pseudoChildTags[\"*\"] ?? \"span\";\n    }\n\n    const placeClass = `${config.prefix}-pseudo-${place}`;\n\n    const pseudoElt = document.createElement(pseudoTag);\n    pseudoElt.setAttribute(\n      \"class\",\n      `${config.prefix}-pseudo ${placeClass} ${pseudoIdClass}`,\n    );\n\n    const detail = {\n      pseudoElt,\n      pseudoId,\n      place,\n    };\n\n    if (dispatchBefore(elt, \"pseudoElement\", detail)) {\n      const insertPosition = detail.place === \"before\"\n        ? \"afterbegin\"\n        : \"beforeend\";\n\n      elt.insertAdjacentElement(insertPosition, detail.pseudoElt);\n\n      dispatchAfter(elt, \"pseudoElement\", detail);\n    }\n  }\n}\n\nfunction createPseudoRule(\n  rule: CSSStyleRule,\n  pseudoId: PseudoId,\n  place: PseudoPlace,\n) {\n  if (!hasInternal(rule, \"pseudoId\")) {\n    // Create a 'pseudo-rule' to target the 'pseudo-element'\n    setInternal(rule, \"pseudoId\", pseudoId);\n\n    const pseudoIdClass = `${config.prefix}-pseudo-${pseudoId}`;\n\n    const selectorText = rule.selectorText.replace(\n      `::${place}`,\n      ` > .${pseudoIdClass}`,\n    );\n    const cssText = rule.cssText.replace(rule.selectorText, selectorText);\n    const pseudoRule = {\n      selectorText,\n      cssText,\n      parentStyleSheet: rule.parentStyleSheet,\n    };\n\n    const detail = {\n      pseudoId,\n      pseudoRule,\n      rule,\n      place,\n      owner: getOwner(rule),\n    };\n\n    const target = resolveElement(rule) ?? document;\n\n    if (dispatchBefore(target, \"pseudoRule\", detail)) {\n      const styleSheet = detail.pseudoRule.parentStyleSheet;\n      if (styleSheet) {\n        const cssRules = styleSheet.cssRules;\n\n        const pseudoRule = cssRules[\n          styleSheet.insertRule(detail.pseudoRule.cssText, cssRules.length)\n        ] as CSSStyleRule;\n\n        if (!detail.owner && styleSheet.href) {\n          detail.owner = styleSheet.href;\n        }\n\n        if (detail.owner) {\n          setOwner(pseudoRule, detail.owner);\n        }\n\n        dispatchAfter(target, \"pseudoRule\", {\n          ...detail,\n          pseudoRule,\n        });\n\n        return pseudoRule;\n      }\n    }\n  }\n}\n", "import { getInternal } from \"./util/internal.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { CssImportDetail } from \"./types.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\n\nexport function processCssImports(\n  rule: CSSStyleRule,\n  onReady?: (link: HTMLLinkElement) => void,\n) {\n  const ruleApplies = !!resolveElement(rule)?.ownerDocument?.querySelector(\n    rule.selectorText,\n  );\n\n  const urls = parseCssValue(\"import\", rule);\n\n  for (const url of urls) {\n    let link = getInternal(rule, \"importLinks\")?.get(url)?.deref();\n\n    if (link) {\n      if (ruleApplies && link.sheet?.disabled) {\n        // Enable a disabled stylesheet if the rule now applies\n        link.sheet.disabled = false;\n        setTimeout(() => {\n          onReady?.(link!);\n        }, 0);\n      } else if (!ruleApplies && link.sheet) {\n        // Disable an existing stylesheet if the rule no longer applies\n        link.sheet.disabled = true;\n      }\n    } else if (ruleApplies) {\n      link = createStyleSheetLink(\n        url,\n        (resolveElement(rule) as HTMLLinkElement)?.crossOrigin ??\n          undefined,\n        onReady,\n      );\n\n      if (link) {\n        getInternal(rule, \"importLinks\", () => new Map()).set(\n          url,\n          new WeakRef(link),\n        );\n      }\n    }\n  }\n}\n\nfunction createStyleSheetLink(\n  url: string,\n  crossOrigin?: string,\n  onReady?: (link: HTMLLinkElement) => void,\n): HTMLLinkElement | undefined {\n  const detail: CssImportDetail = { url, crossOrigin, disabled: false };\n\n  if (dispatchBefore(document, \"cssImport\", detail)) {\n    if (\n      !document.querySelector(`link[rel=\"stylesheet\"][href=\"${detail.url}\"]`)\n    ) {\n      const link = document.createElement(\"link\");\n      link.setAttribute(\"rel\", \"stylesheet\");\n      link.setAttribute(\"href\", detail.url);\n\n      if (typeof detail.crossOrigin === \"string\") {\n        link.setAttribute(\"crossorigin\", detail.crossOrigin);\n      }\n\n      link.addEventListener(\"load\", (event) => {\n        // IMPORTANT: The sheet object may not immediately appear in the DOM,\n        // even after the load event, so we may need to poll until it actually\n        // appears.\n        function process(delay = 1) {\n          setTimeout(() => {\n            if (link.sheet) {\n              dispatchAfter(event.target ?? document, \"cssImport\", detail);\n              onReady?.(link);\n            } else if (delay < 1000) {\n              process(delay * 2);\n            } else {\n              console.error(\n                \"ahx timeout loading stylesheet:\",\n                detail.url,\n                link.sheet,\n              );\n            }\n          }, delay);\n        }\n\n        process();\n      }, { once: true, passive: true });\n\n      document.head.appendChild(link);\n      return link;\n    }\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { AhxCSSPropertyName, RuleId } from \"./types.ts\";\nimport { processControls } from \"./process_controls.ts\";\nimport { processGuards } from \"./process_guards.ts\";\nimport { processPseudoElements } from \"./process_pseudo_elements.ts\";\nimport { getOwner, setOwner } from \"./util/owner.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { processCssImports } from \"./process_css_imports.ts\";\nimport { processRules } from \"./process_rules.ts\";\nimport { hasInternal } from \"./util/internal.ts\";\nimport { asAhxCSSPropertyName, getAhxCSSPropertyNames } from \"./util/names.ts\";\nimport { triggerLoad } from \"./trigger_load.ts\";\nimport { processSlot } from \"./process_slot.ts\";\nimport { getRuleId } from \"./util/rules.ts\";\n\nexport function processRule(\n  rule: CSSStyleRule,\n  props: Set<AhxCSSPropertyName>,\n) {\n  const ruleId = getRuleId(rule);\n\n  if (rule.parentStyleSheet) {\n    processStyleSheet(rule.parentStyleSheet);\n  }\n\n  if (props.size) {\n    const owner = getOwner(rule);\n\n    const detail = { rule, props, owner };\n\n    // TODO: consider whether we should just NOT process\n    // any rule that doesn't have an associated node\n    const target = resolveElement(rule) ?? document;\n\n    if (dispatchBefore(target, \"processRule\", detail)) {\n      if (detail.owner) {\n        setOwner(rule, detail.owner);\n      }\n\n      setRuleId(rule, ruleId, props);\n\n      processCssImports(rule, processImportedRules);\n      processGuards(rule, props);\n\n      const pseudoRule = processPseudoElements(rule);\n      if (pseudoRule) {\n        processRule(pseudoRule, getAhxCSSPropertyNames(pseudoRule));\n      }\n\n      processControls(rule);\n      processSlot(rule);\n\n      dispatchAfter(target, \"processRule\", detail);\n    }\n  }\n}\n\nfunction processStyleSheet(stylesheet: CSSStyleSheet) {\n  if (!hasInternal(stylesheet, \"owner\")) {\n    setOwner(stylesheet, stylesheet.href ?? \"unknown\");\n  }\n}\n\nfunction processImportedRules(link: HTMLLinkElement) {\n  processRules(link);\n  triggerLoad(link.ownerDocument.documentElement);\n}\n\nfunction setRuleId(\n  rule: CSSStyleRule,\n  ruleId: RuleId,\n  props: Set<AhxCSSPropertyName>,\n) {\n  const ruleProp = asAhxCSSPropertyName(\"rule\");\n  if (!props.has(ruleProp)) {\n    rule.style.setProperty(ruleProp, ruleId);\n  }\n\n  const ruleIdProp = asAhxCSSPropertyName(`rule-${ruleId}`);\n  if (!props.has(ruleIdProp)) {\n    rule.style.setProperty(ruleIdProp, ruleId);\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { processRule } from \"./process_rule.ts\";\nimport { getAhxCSSPropertyNames } from \"./util/names.ts\";\nimport type { AhxCSSPropertyName } from \"./types.ts\";\n\nexport function processRules(\n  root: (DocumentOrShadowRoot | LinkStyle) & EventTarget,\n) {\n  const detail = {\n    rules: findRules(root),\n  };\n\n  if (dispatchBefore(root, \"processRules\", detail)) {\n    for (const [rule, props] of detail.rules) {\n      processRule(rule, props);\n    }\n\n    dispatchAfter(root, \"processRules\", detail);\n  }\n}\n\nfunction findRules(\n  root: DocumentOrShadowRoot | LinkStyle,\n): Map<CSSStyleRule, Set<AhxCSSPropertyName>> {\n  const rules = new Map<CSSStyleRule, Set<AhxCSSPropertyName>>();\n\n  function fromStylesheet(stylesheet: CSSStyleSheet) {\n    if (!stylesheet.disabled) {\n      try {\n        fromRuleList(stylesheet.cssRules);\n      } catch {\n        // Skip SecurityError\n      }\n    }\n  }\n\n  function fromRuleList(rules: CSSRuleList) {\n    for (const rule of rules) {\n      if (rule instanceof CSSImportRule && rule.styleSheet) {\n        fromStylesheet(rule.styleSheet);\n      } else if (rule instanceof CSSGroupingRule) {\n        fromRuleList(rule.cssRules);\n      } else if (rule instanceof CSSStyleRule) {\n        fromStyleRule(rule);\n      }\n    }\n  }\n\n  function fromStyleRule(rule: CSSStyleRule) {\n    const props = getAhxCSSPropertyNames(rule);\n    if (props.size > 0) {\n      rules.set(rule, props);\n    }\n  }\n\n  if (\"sheet\" in root && root.sheet) {\n    fromStylesheet(root.sheet);\n  } else if (\"styleSheets\" in root) {\n    for (const stylesheet of root.styleSheets) {\n      fromStylesheet(stylesheet);\n    }\n  }\n\n  return rules;\n}\n", "import { handleAction } from \"./handle_action.ts\";\nimport { parseTarget } from \"./parse_target.ts\";\nimport { getOwner } from \"./util/owner.ts\";\nimport { dequeueAction, queue } from \"./util/queue.ts\";\n\nexport function processQueue() {\n  for (const detail of queue()) {\n    const target = parseTarget(detail.source, detail.control);\n\n    if (target instanceof Element) {\n      dequeueAction(detail);\n\n      handleAction({\n        ...detail,\n        target,\n        targetOwner: getOwner(target),\n      });\n    }\n  }\n}\n", "import { deleteInternal } from \"./util/internal.ts\";\nimport { processElement } from \"./process_element.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { processElements } from \"./process_elements.ts\";\nimport { triggerMutate } from \"./trigger_mutate.ts\";\nimport { triggerLoad } from \"./trigger_load.ts\";\nimport { processRules } from \"./process_rules.ts\";\nimport { processQueue } from \"./process_queue.ts\";\n\nexport function startObserver(root: Document) {\n  const observer = new MutationObserver((mutations) => {\n    const detail = { mutations };\n    if (dispatchBefore(root, \"mutations\", detail)) {\n      const removedNodes = new Set<Node>();\n      const removedElements = new Set<Element>();\n      const addedElements = new Set<Element>();\n      const mutatedElements = new Set<Element>();\n\n      for (const mutation of detail.mutations) {\n        for (const node of mutation.removedNodes) {\n          removedNodes.add(node);\n          if (node instanceof Element) {\n            removedElements.add(node);\n          }\n        }\n\n        for (const node of mutation.addedNodes) {\n          removedNodes.delete(node);\n          if (node instanceof Element) {\n            processElements(node);\n            addedElements.add(node);\n          }\n        }\n\n        if (\n          mutation.type === \"attributes\" && mutation.target instanceof Element\n        ) {\n          processElement(mutation.target);\n        }\n\n        if (mutation.target instanceof Element) {\n          mutatedElements.add(mutation.target);\n        }\n      }\n\n      setTimeout(() => {\n        for (const elt of mutatedElements) {\n          triggerMutate(elt);\n        }\n      }, 0);\n\n      setTimeout(() => {\n        for (const elt of addedElements) {\n          triggerLoad(elt);\n        }\n      });\n\n      processRules(root);\n\n      processQueue();\n\n      dispatchAfter(root, \"mutations\", {\n        ...detail,\n        removedElements,\n        addedElements,\n        mutatedElements,\n      });\n\n      for (const node of removedNodes) {\n        deleteInternalRecursive(node);\n      }\n    }\n  });\n\n  const options: MutationObserverInit = {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true,\n  };\n\n  if (dispatchBefore(root, \"startObserver\", options)) {\n    observer.observe(root, options);\n\n    dispatchAfter(root, \"startObserver\", options);\n  }\n}\n\nfunction deleteInternalRecursive(node: Node) {\n  deleteInternal(node);\n  for (const child of node.childNodes) {\n    deleteInternalRecursive(child);\n  }\n}\n", "export * from \"./debug/internals.ts\";\nexport * from \"./debug/events.ts\";\nexport * from \"./debug/elements.ts\";\nexport * from \"./debug/controls.ts\";\nexport * from \"./debug/owners.ts\";\nexport * from \"./debug/forms.ts\";\nexport * from \"./debug/slots.ts\";\n", "import { internalEntries } from \"../util/internal.ts\";\n\nexport function internals() {\n  console.group(\"ahx internal properties...\");\n\n  let groupObject: unknown;\n  for (const [thing, key, value] of internalEntries()) {\n    if (thing !== groupObject) {\n      if (groupObject) {\n        console.groupEnd();\n      }\n\n      const representation = thing instanceof CSSRule ? thing.cssText : thing;\n\n      console.groupCollapsed(representation);\n      console.dir(thing);\n\n      if (thing instanceof CSSStyleRule) {\n        // console.groupCollapsed('matched nodes...');\n        for (const node of document.querySelectorAll(thing.selectorText)) {\n          console.log(node);\n        }\n        // console.groupEnd();\n      }\n\n      groupObject = thing;\n    }\n\n    if (value instanceof Map) {\n      console.group(\"%s:\", key);\n      for (const entry of value) {\n        console.log(\"%c%s:\", \"font-weight: bold\", ...entry);\n      }\n      console.groupEnd();\n    } else {\n      console.log(\"%c%s:\", \"font-weight: bold\", key, value);\n    }\n  }\n\n  console.groupEnd();\n}\n", "import { config } from \"../config.ts\";\nimport type { AhxEventType, EventType } from \"../types.ts\";\n\ninterface LoggerConfig {\n  group: boolean | \"collapse\";\n  include: (AhxEventType | \"error\" | \"veto\")[];\n}\n\nexport const loggerConfig: LoggerConfig = {\n  group: false,\n  include: [],\n};\n\nexport function eventsAll() {\n  config.enableDebugEvent = true;\n  addEventListener(config.prefix, logger);\n}\n\nexport function eventsNone() {\n  config.enableDebugEvent = false;\n  removeEventListener(config.prefix, logger);\n}\n\nexport function logger({ detail: event }: CustomEvent<CustomEvent>) {\n  const { type, target, detail } = event;\n\n  if (shouldLog(type)) {\n    if (detail?._after && loggerConfig.group) {\n      console.groupEnd();\n    }\n\n    if (detail?._before) {\n      const method = loggerConfig.group\n        ? loggerConfig.group === true ? \"group\" : \"groupCollapsed\"\n        : \"debug\";\n\n      console[method](\"%s -> %o %o\", type, target, detail);\n    } else {\n      console.debug(\"%s -> %o %o\", type, target, detail);\n    }\n  }\n}\n\nfunction shouldLog(type: EventType): boolean {\n  if (loggerConfig.include?.length) {\n    if (loggerConfig.include.some((v) => type.includes(`:${v}`))) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\n", "export function comparePosition(a: Node, b: Node) {\n  if (a === b) {\n    return 0;\n  }\n\n  const position = a.compareDocumentPosition(b);\n\n  if (\n    position & Node.DOCUMENT_POSITION_FOLLOWING ||\n    position & Node.DOCUMENT_POSITION_CONTAINED_BY\n  ) {\n    return -1;\n  } else if (\n    position & Node.DOCUMENT_POSITION_PRECEDING ||\n    position & Node.DOCUMENT_POSITION_CONTAINS\n  ) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n", "import { parseAttrValue } from \"../parse_attr_value.ts\";\nimport { internalEntries } from \"../util/internal.ts\";\nimport type { ControlPropName } from \"../types.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function elements(ahxProp?: ControlPropName) {\n  console.group(\"ahx elements...\");\n\n  const elements = new Set<Element>();\n  const rules = new Set<CSSStyleRule>();\n\n  for (const [thing] of internalEntries()) {\n    if (thing instanceof Element) {\n      elements.add(thing);\n    } else if (thing instanceof CSSStyleRule) {\n      rules.add(thing);\n    }\n  }\n\n  for (const rule of rules) {\n    for (const node of document.querySelectorAll(rule.selectorText)) {\n      if (node instanceof Element) {\n        elements.add(node);\n      }\n    }\n  }\n\n  for (const elt of [...elements].sort(comparePosition)) {\n    if (ahxProp) {\n      const tokens = parseAttrValue(ahxProp, elt);\n      if (tokens.length) {\n        console.log(elt, ...tokens);\n      }\n    } else {\n      console.log(elt);\n    }\n  }\n\n  console.groupEnd();\n}\n", "import { isDenied } from \"../handle_trigger.ts\";\nimport { internalEntries } from \"../util/internal.ts\";\nimport type { ControlDecl, ControlSpec, EventType } from \"../types.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function controls(verbose = false) {\n  console.group(\"ahx controls...\");\n\n  const elements = new Map<Element, Map<ControlSpec, ControlDecl>>();\n\n  function addControl(\n    elt: Element,\n    ctlDecl: ControlDecl,\n    ctlSpec: ControlSpec,\n  ) {\n    if (!elements.has(elt)) {\n      elements.set(elt, new Map());\n    }\n    elements.get(elt)!.set(ctlSpec, ctlDecl);\n  }\n\n  for (const [ctlDecl, key, ctlSpec] of internalEntries()) {\n    if (key.startsWith(\"control:\")) {\n      if (ctlDecl instanceof Element) {\n        addControl(ctlDecl, ctlDecl, ctlSpec as ControlSpec);\n      } else if (ctlDecl instanceof CSSStyleRule) {\n        for (const node of document.querySelectorAll(ctlDecl.selectorText)) {\n          if (node instanceof Element) {\n            addControl(node, ctlDecl, ctlSpec as ControlSpec);\n          }\n        }\n      }\n    }\n  }\n\n  const orderedElements = [...elements.keys()].sort(comparePosition);\n\n  for (const elt of orderedElements) {\n    const controls = elements.get(elt) ?? [];\n    const events = new Set<EventType>();\n    const denied = isDenied(elt);\n\n    for (const [{ trigger }] of controls) {\n      events.add(trigger.eventType);\n    }\n\n    console.groupCollapsed(\n      \"%o : %c%s\",\n      elt,\n      denied ? \"text-decoration: line-through; color: grey\" : \"color: red\",\n      [...events].join(\", \"),\n    );\n\n    for (const [{ trigger, action, swap }, control] of controls) {\n      if (verbose) {\n        console.log(\n          \"trigger:\",\n          trigger,\n          \"action:\",\n          action,\n          \"swap:\",\n          swap,\n          \"control:\",\n          control,\n        );\n      } else {\n        const ctlRep = control instanceof Element ? \"element\" : control.cssText;\n\n        const actionRep = \"method\" in action\n          ? `${action.method.toUpperCase()} ${action.url}`\n          : action.type;\n\n        const swapRep = (swap.swapStyle ?? \"default\") +\n          (swap.itemName ? ` ${swap.itemName}` : \"\");\n\n        console.log(\n          \"%c%s%c -> %c%s%c -> %c%s%c from: %c%s%c\",\n          \"color: red; font-weight: bold\",\n          trigger.eventType,\n          \"color: inherit; font-weight: normal\",\n          \"color: green\",\n          actionRep,\n          \"color: inherit\",\n          \"color: darkorange\",\n          swapRep,\n          \"color: inherit\",\n          \"color: hotpink\",\n          ctlRep,\n          \"color: inherit\",\n        );\n      }\n    }\n\n    console.groupEnd();\n  }\n\n  console.groupEnd();\n}\n", "import { getInternal, internalEntries } from \"../util/internal.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function owners() {\n  console.group(\"ahx ownership...\");\n\n  const elements = new Set<Element>();\n\n  for (const [thing, key, owner] of internalEntries()) {\n    if (thing instanceof Element) {\n      elements.add(thing);\n    } else if (key === \"owner\") {\n      if (thing instanceof CSSRule) {\n        console.log(\"%o -> %s\", thing.cssText, owner);\n      } else {\n        console.log(\"%o -> %s\", thing, owner);\n      }\n    }\n  }\n\n  for (const elt of [...elements].sort(comparePosition)) {\n    const owner = getInternal(elt, \"owner\");\n    console.log(\"%o -> %s\", elt, owner ?? \"none\");\n  }\n\n  console.groupEnd();\n}\n", "import { isRuleEnabled } from \"../util/rules.ts\";\nimport {\n  getInternal,\n  internalEntries,\n  objectsWithInternal,\n} from \"../util/internal.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\nimport type { ActionType, ControlSpec } from \"../types.ts\";\nimport { parseTarget } from \"../parse_target.ts\";\n\nexport function forms() {\n  console.group(\"ahx form...\");\n\n  const elements = new Set<Element>();\n\n  for (const [elt] of objectsWithInternal(\"formData\")) {\n    if (elt instanceof Element) {\n      elements.add(elt);\n    }\n  }\n\n  for (const [rule] of getControlRulesByAction(\"harvest\")) {\n    for (const elt of document.querySelectorAll(rule.selectorText)) {\n      const target = parseTarget(elt, rule);\n      if (target instanceof Element) {\n        elements.add(target);\n      }\n    }\n  }\n\n  for (const elt of [...elements].sort(comparePosition)) {\n    const formData = elt instanceof HTMLFormElement\n      ? new FormData(elt)\n      : getInternal(elt, \"formData\");\n\n    if (formData) {\n      console.group(elt);\n\n      for (const [name, value] of formData ?? []) {\n        console.log(\"%s: %c%s\", name, \"font-weight: bold\", value);\n      }\n\n      console.groupEnd();\n    }\n  }\n\n  console.groupEnd();\n}\n\nfunction* getControlRulesByAction(\n  type: ActionType,\n): Iterable<[CSSStyleRule, ControlSpec]> {\n  for (const [rule, key, control] of internalEntries()) {\n    if (\n      key.startsWith(\"control:\") && rule instanceof CSSStyleRule &&\n      typeof control === \"object\" && \"action\" in control &&\n      control.action.type === type && isRuleEnabled(rule)\n    ) {\n      yield [rule, control as ControlSpec];\n    }\n  }\n}\n", "import { objectsWithInternal } from \"../util/internal.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function slots() {\n  console.group(\"ahx slots...\");\n\n  const slots = new Map<Element, Set<string>>();\n\n  function addSlot(elt: Element, names: Set<string>) {\n    const nameSet = slots.get(elt) ??\n      slots.set(elt, new Set<string>()).get(elt)!;\n    names.forEach((name) => nameSet.add(name));\n  }\n\n  for (const [thing, slotNames] of objectsWithInternal(\"slotName\")) {\n    if (thing instanceof Element) {\n      addSlot(thing, slotNames);\n    } else if (thing instanceof CSSStyleRule) {\n      const slots = document.querySelectorAll(thing.selectorText);\n      for (const slot of slots) {\n        addSlot(slot, slotNames);\n      }\n    }\n  }\n\n  for (const elt of [...slots.keys()].sort(comparePosition)) {\n    console.log(elt, ...slots.get(elt)!);\n  }\n\n  console.groupEnd();\n}\n", "import { config } from \"./config.ts\";\n\nexport function applyUrlAttrs(elt: Element, loc: Location) {\n  if (elt && elt.getAttribute(`${config.prefix}-url-href`) !== loc.href) {\n    setAttr(\"href\", loc.href);\n    setAttr(\"host\", loc.host);\n    setAttr(\"path\", loc.pathname);\n    setAttr(\"search\", loc.search);\n    setAttr(\"hash\", loc.hash);\n  }\n\n  function setAttr(prop: string, value?: string) {\n    const attr = `${config.prefix}-url-${prop}`;\n    if (value) {\n      elt.setAttribute(attr, value);\n    } else {\n      elt.removeAttribute(attr);\n    }\n  }\n}\n\nexport function initUrlAttrs(document: Document) {\n  function listener() {\n    applyUrlAttrs(document.documentElement, document.location);\n  }\n\n  [\n    \"DOMContentLoaded\",\n    \"load\",\n    \"hashchange\",\n    \"popstate\",\n  ]\n    .forEach((event) => {\n      addEventListener(event, listener);\n    });\n\n  listener();\n}\n", "/// <reference lib=\"dom\"/>\n/// <reference lib=\"dom.iterable\"/>\n/// <reference lib=\"dom.asynciterable\"/>\n\nimport { ready } from \"./ready.ts\";\nimport { startObserver } from \"./start_observer.ts\";\nimport { processElements } from \"./process_elements.ts\";\nimport { processRules } from \"./process_rules.ts\";\nimport * as ahx from \"./debug.ts\";\nimport { initUrlAttrs } from \"./url_attrs.ts\";\nimport { triggerLoad } from \"./trigger_load.ts\";\n\nready((document) => {\n  initUrlAttrs(document);\n\n  startObserver(document);\n\n  processRules(document);\n\n  processElements(document);\n\n  triggerLoad(document.documentElement);\n});\n\n// deno-lint-ignore no-explicit-any\n(window as any).ahx = ahx;\n"],
  "mappings": "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",
  "names": ["isReady", "ready", "fn", "values", "weakRefs", "toWeakRef", "setInternal", "obj", "key", "value", "weakRef", "getInternal", "initializer", "hasInternal", "deleteInternal", "valueMap", "cloneInternal", "src", "dst", "objectsWithInternal", "internalEntries", "thing", "config", "dispatch", "target", "type", "detail", "cancelable", "event", "config", "dispatchOneShot", "name", "dispatchBefore", "permitted", "dispatchAfter", "dispatchError", "getAhxCSSPropertyNames", "rule", "names", "name", "isAhxCSSPropertyName", "hasAhxAttributes", "elt", "attr", "isAhxAttributeName", "config", "isAhxHeaderName", "asAhxCSSPropertyName", "asAhxAttributeName", "asAhxHeaderName", "getOwner", "thing", "hasInternal", "getInternal", "setOwner", "owner", "setInternal", "parseCssValue", "prop", "rule", "elt", "expect", "asAhxCSSPropertyName", "value", "isAttr", "parseURL", "isProp", "propValue", "isURL", "values", "baseURL", "url", "parseQuoted", "e", "isQuoted", "parseAttrValue", "prop", "control", "expect", "asAhxAttributeName", "value", "parseAttrOrCssValue", "parseCssValue", "parseTriggers", "control", "rawValue", "parseAttrOrCssValue", "triggerSpecs", "triggerValues", "triggerValue", "trigger", "modifiers", "triggerSpec", "modifier", "parseActions", "control", "actionSpecs", "method", "config", "url", "parseAttrOrCssValue", "parseURL", "getAhxCSSPropertyNames", "asAhxCSSPropertyName", "baseURL", "parseInterval", "str", "parseSwap", "control", "tokens", "parseAttrOrCssValue", "swapSpec", "token", "modifier", "value", "parseInterval", "querySelectorExt", "elt", "query", "_query", "_query", "elt", "query", "all", "single", "axis", "selector", "splitQuery", "next", "previous", "found", "spaceIndex", "start", "results", "i", "readableStreamIterator", "reader", "done", "value", "HTMLBodyElementParserStream", "document", "template", "parser", "container", "chunk", "controller", "element", "findSlots", "query", "root", "name", "selector", "splitQuery", "slots", "thing", "slotNames", "objectsWithInternal", "slot", "spaceIndex", "swapHtml", "props", "response", "target", "document", "index", "previous", "replacePrevious", "elements", "HTMLBodyElementParserStream", "element", "config", "swapStyle", "targets", "slot", "parseAttrValue", "slotTargets", "findSlots", "templateElement", "detail", "dispatchBefore", "controlOwner", "setOwner", "swapHandlers", "dispatchAfter", "swapAdjacent", "pos", "pseudoPrefix", "cls", "cloneInternal", "swapAttr", "props", "target", "itemName", "merge", "detail", "join", "dispatchBefore", "value", "dispatchAfter", "oldValue", "newValue", "sep", "values", "swapInput", "props", "target", "itemName", "merge", "value", "detail", "createInput", "getInternal", "oldValue", "join", "dispatchBefore", "input", "formData", "dispatchAfter", "name", "document", "newValue", "sep", "values", "swapText", "props", "swapStyle", "swapInput", "swapAttr", "handleSwap", "props", "swapStyle", "response", "itemName", "value", "swapText", "isHtmlResponse", "swapHtml", "handleRequest", "props", "source", "action", "target", "swap", "controlOwner", "targetOwner", "request", "prepareRequest", "detail", "dispatchBefore", "response", "dispatchAfter", "asAhxHeaderName", "handleSwap", "error", "formData", "dispatchError", "url", "headers", "init", "key", "value", "containsFile", "handleHarvest", "props", "event", "source", "action", "target", "swap", "control", "controlOwner", "targetOwner", "newValue", "parseCssValue", "oldValue", "getOldValue", "detail", "dispatchBefore", "handleSwap", "dispatchAfter", "handleAction", "detail", "source", "control", "action", "query", "parseAttrOrCssValue", "include", "querySelectorExt", "getFormData", "url", "parseCssValue", "dispatchBefore", "handleRequest", "handleHarvest", "dispatchAfter", "elt", "hasInternal", "getInternal", "actionQueue", "enqueueAction", "detail", "dispatchBefore", "dequeueAction", "dispatchAfter", "queue", "handleTrigger", "detail", "control", "trigger", "source", "isDenied", "dispatchError", "getInternal", "dispatchBefore", "doAction", "dispatchAfter", "hasTarget", "handleAction", "enqueueAction", "elt", "deny", "parseAttrOrCssValue", "AHX_EVENTS", "toDOMEventType", "type", "config", "fromDOMEventType", "prefix", "isRuleEnabled", "rule", "ruleCount", "getRuleId", "rule", "getInternal", "getControlsFromElements", "eventType", "root", "recursive", "ctlSpec", "getInternal", "elt", "objectsWithInternal", "getControlsFromRules", "rule", "isRuleEnabled", "getControls", "parseTarget", "elt", "control", "targetQuery", "parseAttrOrCssValue", "hasAwait", "target", "querySelectorExt", "eventTypes", "initEventListener", "eventType", "detail", "dispatchBefore", "toDOMEventType", "eventListener", "dispatchAfter", "event", "getTriggerDetailsForEvent", "handleTrigger", "controls", "getControls", "fromDOMEventType", "isRecursive", "source", "control", "ctlSpec", "target", "parseTarget", "getOwner", "resolveElement", "thing", "processControl", "detail", "target", "resolveElement", "dispatchBefore", "control", "trigger", "action", "swap", "eventType", "setInternal", "initEventListener", "dispatchAfter", "processControls", "control", "triggers", "parseTriggers", "actions", "parseActions", "swap", "parseSwap", "trigger", "action", "processControl", "processSlot", "control", "slotNames", "parseAttrOrCssValue", "names", "getInternal", "name", "processElement", "elt", "hasAhxAttributes", "detail", "getOwner", "dispatchBefore", "setOwner", "processControls", "processSlot", "dispatchAfter", "processElements", "root", "selectors", "config", "attr", "asAhxAttributeName", "detail", "dispatchBefore", "processed", "selector", "processElement", "elt", "dispatchAfter", "triggerMutate", "elt", "dispatchOneShot", "triggerLoad", "elt", "dispatchOneShot", "processGuards", "rule", "props", "prop", "asAhxCSSPropertyName", "value", "parseCssValue", "setInternal", "dispatchError", "nextPseudoId", "processPseudoElements", "rule", "before", "after", "pseudoId", "getInternal", "place", "parentSelector", "elt", "createPseudoElement", "createPseudoRule", "pseudoIdClass", "config", "parentTag", "pseudoTag", "dispatchError", "placeClass", "pseudoElt", "detail", "dispatchBefore", "insertPosition", "dispatchAfter", "hasInternal", "setInternal", "selectorText", "cssText", "pseudoRule", "getOwner", "target", "resolveElement", "styleSheet", "cssRules", "setOwner", "processCssImports", "rule", "onReady", "ruleApplies", "resolveElement", "urls", "parseCssValue", "url", "link", "getInternal", "createStyleSheetLink", "crossOrigin", "detail", "dispatchBefore", "event", "process", "delay", "dispatchAfter", "processRule", "rule", "props", "ruleId", "getRuleId", "processStyleSheet", "owner", "getOwner", "detail", "target", "resolveElement", "dispatchBefore", "setOwner", "setRuleId", "processCssImports", "processImportedRules", "processGuards", "pseudoRule", "processPseudoElements", "getAhxCSSPropertyNames", "processControls", "processSlot", "dispatchAfter", "stylesheet", "hasInternal", "link", "processRules", "triggerLoad", "ruleProp", "asAhxCSSPropertyName", "ruleIdProp", "processRules", "root", "detail", "findRules", "dispatchBefore", "rule", "props", "processRule", "dispatchAfter", "rules", "fromStylesheet", "stylesheet", "fromRuleList", "fromStyleRule", "getAhxCSSPropertyNames", "processQueue", "detail", "queue", "target", "parseTarget", "dequeueAction", "handleAction", "getOwner", "startObserver", "root", "observer", "mutations", "detail", "dispatchBefore", "removedNodes", "removedElements", "addedElements", "mutatedElements", "mutation", "node", "processElements", "processElement", "elt", "triggerMutate", "triggerLoad", "processRules", "processQueue", "dispatchAfter", "deleteInternalRecursive", "options", "deleteInternal", "child", "debug_exports", "__export", "controls", "elements", "eventsAll", "eventsNone", "forms", "internals", "logger", "loggerConfig", "owners", "slots", "internals", "groupObject", "thing", "key", "value", "internalEntries", "representation", "node", "entry", "loggerConfig", "eventsAll", "config", "logger", "eventsNone", "event", "type", "target", "detail", "shouldLog", "method", "v", "comparePosition", "a", "b", "position", "elements", "ahxProp", "rules", "thing", "internalEntries", "rule", "node", "elt", "comparePosition", "tokens", "parseAttrValue", "controls", "verbose", "elements", "addControl", "elt", "ctlDecl", "ctlSpec", "key", "internalEntries", "node", "orderedElements", "comparePosition", "events", "denied", "isDenied", "trigger", "action", "swap", "control", "ctlRep", "actionRep", "swapRep", "owners", "elements", "thing", "key", "owner", "internalEntries", "elt", "comparePosition", "getInternal", "forms", "elements", "elt", "objectsWithInternal", "rule", "getControlRulesByAction", "target", "parseTarget", "comparePosition", "formData", "getInternal", "name", "value", "type", "key", "control", "internalEntries", "isRuleEnabled", "slots", "addSlot", "elt", "names", "nameSet", "name", "thing", "slotNames", "objectsWithInternal", "slot", "comparePosition", "applyUrlAttrs", "elt", "loc", "config", "setAttr", "prop", "value", "attr", "initUrlAttrs", "document", "listener", "event", "ready", "document", "initUrlAttrs", "startObserver", "processRules", "processElements", "triggerLoad", "debug_exports"]
}
