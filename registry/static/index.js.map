{
  "version": 3,
  "sources": ["../../../ahx_lib/lib/ready.ts", "../../../ahx_lib/lib/util/internal.ts", "../../../ahx_lib/lib/config.ts", "../../../ahx_lib/lib/util/dispatch.ts", "../../../ahx_lib/lib/util/names.ts", "../../../ahx_lib/lib/util/owner.ts", "../../../ahx_lib/lib/parse_css_value.ts", "../../../ahx_lib/lib/parse_attr_value.ts", "../../../ahx_lib/lib/util/query_selector.ts", "../../../ahx_lib/ext/polyfill/ReadableStream_asyncIterator.js", "../../../ahx_lib/ext/HTMLBodyElementParserStream.js", "../../../ahx_lib/lib/util/slots.ts", "../../../ahx_lib/lib/swap_html.ts", "../../../ahx_lib/lib/swap_attr.ts", "../../../ahx_lib/lib/swap_input.ts", "../../../ahx_lib/lib/swap_text.ts", "../../../ahx_lib/lib/handle_swap.ts", "../../../ahx_lib/lib/handle_request.ts", "../../../ahx_lib/lib/handle_harvest.ts", "../../../ahx_lib/lib/handle_action.ts", "../../../ahx_lib/lib/handle_trigger.ts", "../../../ahx_lib/lib/util/resolve_element.ts", "../../../ahx_lib/lib/util/event.ts", "../../../ahx_lib/lib/util/rules.ts", "../../../ahx_lib/lib/util/triggers.ts", "../../../ahx_lib/lib/parse_target.ts", "../../../ahx_lib/lib/triggers.ts", "../../../ahx_lib/lib/parse_interval.ts", "../../../ahx_lib/lib/parse_triggers.ts", "../../../ahx_lib/lib/parse_actions.ts", "../../../ahx_lib/lib/parse_swap.ts", "../../../ahx_lib/lib/process_triggers.ts", "../../../ahx_lib/lib/process_element.ts", "../../../ahx_lib/lib/process_elements.ts", "../../../ahx_lib/lib/trigger_mutate.ts", "../../../ahx_lib/lib/trigger_load.ts", "../../../ahx_lib/lib/process_guards.ts", "../../../ahx_lib/lib/process_pseudo_elements.ts", "../../../ahx_lib/lib/process_css_imports.ts", "../../../ahx_lib/lib/process_slot.ts", "../../../ahx_lib/lib/process_rule.ts", "../../../ahx_lib/lib/process_rules.ts", "../../../ahx_lib/lib/start_observer.ts", "../../../ahx_lib/lib/debug/events.ts", "../../../ahx_lib/lib/debug.ts", "../../../ahx_lib/lib/debug/internals.ts", "../../../ahx_lib/lib/debug/compare_position.ts", "../../../ahx_lib/lib/debug/elements.ts", "../../../ahx_lib/lib/debug/triggers.ts", "../../../ahx_lib/lib/debug/owners.ts", "../../../ahx_lib/lib/debug/forms.ts", "../../../ahx_lib/lib/url_attrs.ts", "../../../ahx_lib/lib/ahx.ts"],
  "sourcesContent": ["let isReady = false;\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  isReady = true;\n}, { once: true, passive: true });\n\nexport function ready(fn: (document: Document) => void) {\n  if (isReady) {\n    fn(document);\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", () => fn(document), {\n      once: true,\n      passive: true,\n    });\n  }\n}\n", "import type {\n  CSSPropertyName,\n  EventType,\n  Owner,\n  PseudoId,\n  Trigger,\n} from \"../types.ts\";\n\ntype Thing = Node | CSSRule | StyleSheet;\n\ntype TriggerProps = {\n  [K in `trigger:${EventType}`]: Trigger;\n};\n\ninterface Props extends TriggerProps {\n  // CSSStyleRule\n  \"pseudoId\": PseudoId;\n  \"importLinks\": Map<CSSPropertyName, WeakRef<HTMLLinkElement>>;\n  \"denyTrigger\": true;\n  \"slotName\": Set<string>;\n\n  // Element\n  \"triggeredOnce\": true;\n  \"delayed\": ReturnType<typeof setTimeout>;\n  \"formData\": FormData;\n\n  // Common\n  \"owner\": Owner;\n}\n\nexport type Key = keyof Props;\n\nconst values = new Map<Key, WeakMap<Thing, Props[Key]>>();\n\n// Maintain an iterable set of WeakRefs to the objects with internal properties\nconst weakRefs = new Set<WeakRef<Thing>>();\nconst toWeakRef = new WeakMap<Thing, WeakRef<Thing>>();\n\n/**\n * Set an internal property associated with a DOM object\n */\nexport function setInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n  value: Props[K],\n) {\n  if (!values.has(key)) {\n    values.set(key, new WeakMap());\n  }\n\n  values.get(key)!.set(obj, value);\n\n  if (!toWeakRef.has(obj)) {\n    const weakRef = new WeakRef(obj);\n    weakRefs.add(weakRef);\n    toWeakRef.set(obj, weakRef);\n  }\n}\n\n/**\n * Get an internal property from a DOM object.\n * Optionally initializing that property if it doesn't already exist,\n * this is handy where the property is a Map or Set.\n */\nexport function getInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n  initializer: () => Props[K],\n): Props[K];\nexport function getInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n): Props[K] | undefined;\nexport function getInternal<K extends Key>(\n  obj: Thing,\n  key: K,\n  initializer?: () => Props[K],\n): Props[K] | undefined {\n  if (initializer && !hasInternal(obj, key)) {\n    setInternal(obj, key, initializer());\n  }\n  return values.get(key)?.get(obj) as Props[K] | undefined;\n}\n\n/**\n * Check whether a internal property exists on a DOM object.\n */\nexport function hasInternal(obj: Thing, key: Key): boolean {\n  return !!values.get(key)?.has(obj);\n}\n\n/**\n * Delete one or all internal properties from a DOM object.\n */\nexport function deleteInternal(obj: Thing, key?: Key): void {\n  if (key) {\n    values.get(key)?.delete(obj);\n  } else {\n    for (const valueMap of values.values()) {\n      valueMap.delete(obj);\n    }\n    const weakRef = toWeakRef.get(obj);\n    if (weakRef) {\n      weakRefs.delete(weakRef);\n      toWeakRef.delete(obj);\n    }\n  }\n}\n\n/**\n * Find all DOM objects that have a specific internal property set.\n * @returns tuples of the object and its property value\n */\nexport function* objectsWithInternal<K extends Key>(\n  key: K,\n): Iterable<[Thing, Props[K]]> {\n  const valueMap = values.get(key);\n  if (valueMap) {\n    for (const weakRef of weakRefs) {\n      const obj = weakRef.deref();\n      if (obj && valueMap.has(obj)) {\n        yield [obj, valueMap.get(obj) as Props[K]];\n      }\n    }\n  }\n}\n\n/**\n * Iterate across all internal properties of all objects\n * @returns tuples of an object, property key, and property value on the object\n */\nexport function* internalEntries<K extends Key>(): Iterable<\n  [Thing, K, Props[K]]\n> {\n  for (const weakRef of weakRefs) {\n    const obj = weakRef.deref();\n    if (obj) {\n      for (const [key, valueMap] of values.entries()) {\n        if (valueMap.has(obj)) {\n          yield [obj, key as K, valueMap.get(obj) as Props[K]];\n        }\n      }\n    }\n  }\n}\n", "import type { AhxHttpMethod, AhxName, Prefix } from \"./types.ts\";\n\ninterface Config {\n  prefix: Prefix;\n  httpMethods: AhxHttpMethod[];\n  ahxAttrs: AhxName[];\n  maxLoopCount: number;\n  defaultDelay: number;\n  defaultSettleDelay: number;\n  defaultSwapDelay: number;\n  enableDebugEvent: boolean;\n  pseudoChildTags: Record<string, string | null | undefined>;\n}\n\nexport const config: Config = {\n  prefix: \"ahx\",\n\n  httpMethods: [\n    \"get\",\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\",\n  ],\n\n  ahxAttrs: [\n    \"trigger\",\n    \"target\",\n  ],\n\n  maxLoopCount: 10,\n\n  defaultDelay: 20,\n  defaultSettleDelay: 20,\n  defaultSwapDelay: 0,\n\n  enableDebugEvent: false,\n\n  // parent tag -> default child pseudo tag (or null if a child is not permitted)\n  pseudoChildTags: {\n    \"article\": \"div\",\n    \"aside\": \"div\",\n    \"audio\": \"track\",\n    \"body\": \"div\",\n    \"canvas\": null,\n    \"colgroup\": \"col\",\n    \"datalist\": \"option\",\n    \"dl\": \"dt\",\n    \"footer\": \"div\",\n    \"form\": \"fieldset\",\n    \"head\": null,\n    \"header\": \"div\",\n    \"hgroup\": \"div\",\n    \"html\": null,\n    \"iframe\": null,\n    \"main\": \"div\",\n    \"map\": \"area\",\n    \"menu\": \"li\",\n    \"noscript\": null,\n    \"object\": null,\n    \"ol\": \"li\",\n    \"optgroup\": \"option\",\n    \"picture\": \"source\",\n    \"portal\": null,\n    \"pre\": null,\n    \"script\": null,\n    \"section\": \"div\",\n    \"select\": \"option\",\n    \"style\": null,\n    \"table\": \"tbody\",\n    \"tbody\": \"tr\",\n    \"template\": null,\n    \"textarea\": null,\n    \"tfoot\": \"tr\",\n    \"thead\": \"tr\",\n    \"tr\": \"td\",\n    \"ul\": \"li\",\n    \"video\": \"track\",\n\n    // void elements\n    \"area\": null,\n    \"base\": null,\n    \"br\": null,\n    \"col\": null,\n    \"embed\": null,\n    \"hr\": null,\n    \"img\": null,\n    \"input\": null,\n    \"link\": null,\n    \"meta\": null,\n    \"param\": null,\n    \"source\": null,\n    \"track\": null,\n    \"wbr\": null,\n\n    // default for all other parents\n    \"*\": \"span\",\n  },\n};\n", "import { config } from \"../config.ts\";\nimport type { AhxErrorMap, AhxEventMap, EventType } from \"../types.ts\";\n\nfunction dispatch<T>(\n  target: EventTarget | undefined | null,\n  type: EventType,\n  detail?: T,\n  cancelable = true,\n): boolean {\n  if (target !== null) {\n    const event = new CustomEvent(type, {\n      bubbles: !!target,\n      cancelable,\n      detail,\n    });\n\n    if (config.enableDebugEvent) {\n      dispatchEvent(\n        new CustomEvent(config.prefix, {\n          bubbles: false,\n          cancelable: false,\n          detail: {\n            type: event.type,\n            target,\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            detail: event.detail,\n          },\n        }),\n      );\n    }\n\n    return target && \"dispatchEvent\" in target\n      ? target.dispatchEvent(event)\n      : dispatchEvent(event);\n  }\n  return false;\n}\n\nexport function dispatchOneShot<E extends keyof AhxEventMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail?: AhxEventMap[E][0],\n): void {\n  dispatch(target, `${config.prefix}:${name}`, detail, false);\n}\n\nexport function dispatchBefore<E extends keyof AhxEventMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail: AhxEventMap[E][0],\n): boolean {\n  // @ts-ignore to aid logging\n  detail._before = true;\n\n  const permitted = dispatch(target, `${config.prefix}:${name}`, detail);\n\n  // @ts-ignore to aid logging\n  delete detail._before;\n\n  if (!permitted) {\n    dispatch(target, `${config.prefix}:${name}:veto`, detail, false);\n  }\n\n  return permitted;\n}\n\nexport function dispatchAfter<E extends keyof AhxEventMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail?: AhxEventMap[E][1],\n): void {\n  // @ts-ignore to aid logging\n  detail._after = true;\n\n  dispatch(target, `${config.prefix}:${name}:done`, detail, false);\n\n  // @ts-ignore to aid logging\n  delete detail._after;\n}\n\nexport function dispatchError<E extends keyof AhxErrorMap>(\n  target: EventTarget | undefined | null,\n  name: E,\n  detail?: AhxErrorMap[E],\n): void {\n  dispatch(target, `${config.prefix}:${name}:error`, {\n    error: name,\n    ...detail,\n  }, false);\n}\n", "import { config } from \"../config.ts\";\nimport type {\n  AhxAttributeName,\n  AhxCSSPropertyName,\n  AhxName,\n} from \"../types.ts\";\n\nexport function getAhxCSSPropertyNames(\n  rule: CSSStyleRule,\n): Set<AhxCSSPropertyName> {\n  const names = new Set<AhxCSSPropertyName>();\n  for (const name of rule.style) {\n    if (isAhxCSSPropertyName(name)) {\n      names.add(name);\n    }\n  }\n  return names;\n}\n\nexport function hasAhxAttributes(elt: Element): boolean {\n  for (const attr of elt.attributes) {\n    if (isAhxAttributeName(attr.name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isAhxCSSPropertyName(name: string): name is AhxCSSPropertyName {\n  return name.startsWith(`--${config.prefix}-`);\n}\n\nexport function isAhxAttributeName(name: string): name is AhxAttributeName {\n  return name.startsWith(`${config.prefix}-`);\n}\n\nexport function asAhxCSSPropertyName(\n  name: AhxName | AhxCSSPropertyName | AhxAttributeName,\n): AhxCSSPropertyName {\n  return isAhxCSSPropertyName(name)\n    ? name\n    : isAhxAttributeName(name)\n    ? `--${name}`\n    : `--${config.prefix}-${name}`;\n}\n\nexport function asAhxAttributeName(\n  name: AhxName | AhxAttributeName | AhxCSSPropertyName,\n): AhxAttributeName {\n  return isAhxAttributeName(name)\n    ? name\n    : isAhxCSSPropertyName(name)\n    ? name.substring(2) as AhxAttributeName\n    : `${config.prefix}-${name}`;\n}\n", "import { getInternal, hasInternal, setInternal } from \"./internal.ts\";\nimport type { Owner } from \"../types.ts\";\n\nexport function getOwner(origin: CSSRule | StyleSheet | Element) {\n  if (hasInternal(origin, \"owner\")) {\n    return getInternal(origin, \"owner\");\n  }\n\n  if (origin instanceof StyleSheet) {\n    return getInternal(origin, \"owner\") ?? origin.href ?? undefined;\n  }\n\n  if (origin instanceof CSSRule && origin.parentStyleSheet) {\n    return getOwner(origin.parentStyleSheet);\n  }\n\n  if (origin instanceof Element && origin.parentElement) {\n    return getOwner(origin.parentElement);\n  }\n}\n\nexport function setOwner(origin: CSSRule | StyleSheet | Element, owner: Owner) {\n  // TODO: dispatch ahx:setOwner event?\n  if (owner !== getOwner(origin)) {\n    setInternal(origin, \"owner\", owner);\n  }\n}\n", "import { asAhxCSSPropertyName } from \"./util/names.ts\";\nimport type {\n  AhxAttributeName,\n  AhxCSSPropertyName,\n  AhxName,\n  ValueType,\n} from \"./types.ts\";\n\nexport function parseCssValue(\n  prop: AhxName | AhxCSSPropertyName | AhxAttributeName,\n  rule: CSSStyleRule,\n  elt?: Element,\n  expect: ValueType = \"tokens\",\n): string[] {\n  prop = asAhxCSSPropertyName(prop);\n\n  let value: string | undefined = rule.style.getPropertyValue(prop)?.trim();\n\n  if (value) {\n    // match: attr(<name> <type?>)\n    if (elt) {\n      const isAttr = /^attr\\(([^\\)\\s,]+)(?:\\s+([^\\)\\s,]+))?\\)$/.exec(value);\n      if (isAttr) {\n        value = elt.getAttribute(isAttr[1]) ?? undefined;\n        if (value && isAttr[2] === \"url\") {\n          value = parseURL(value, elt.baseURI);\n        }\n        return value ? [value] : [];\n      } else {\n        // match: --prop(<name> <type?>)\n        const isProp = /^--prop\\(([^\\)\\s,]+)(?:\\s+([^\\)\\s,]+))?\\)$/.exec(value);\n        if (isProp) {\n          value = undefined;\n          const propValue = elt[isProp[1] as keyof Element];\n          if (isProp[2] === \"url\" && typeof propValue === \"string\") {\n            value = parseURL(propValue, elt.baseURI);\n          } else if (\n            typeof propValue === \"string\" || typeof propValue === \"number\" ||\n            typeof propValue === \"boolean\"\n          ) {\n            value = String(propValue);\n          }\n          return value ? [value] : [];\n        }\n      }\n    }\n\n    // match: url(<url?>)\n    const isURL = /^url\\(([^\\)]*)\\)$/.exec(value);\n    if (isURL) {\n      value = isURL[1];\n    }\n\n    value = parseQuoted(value);\n\n    if (isURL) {\n      const baseURL = rule.parentStyleSheet?.href ??\n        rule.style.parentRule?.parentStyleSheet?.href ??\n        elt?.baseURI;\n      value = parseURL(value, baseURL);\n      return value ? [value] : [];\n    }\n  }\n\n  return value\n    ? (expect === \"tokens\" ? value.split(/\\s+/).map(parseQuoted) : [value])\n    : [];\n\n  function parseURL(value: string, baseURL?: string) {\n    try {\n      return new URL(value, baseURL).href;\n    } catch (e) {\n      console.error(e, value, baseURL);\n    }\n  }\n}\n\nfunction parseQuoted(value: string): string {\n  // match: \"<string?>\" or '<string?>'\n  const isQuoted = /^\\\"([^\\\"]*)\\\"$/.exec(value) ??\n    /^\\'([^\\']*)\\'$/.exec(value);\n  if (isQuoted) {\n    return isQuoted[1];\n  }\n  return value;\n}\n", "import { asAhxAttributeName } from \"./util/names.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\nimport type {\n  AhxAttributeName,\n  AhxCSSPropertyName,\n  AhxName,\n  ValueType,\n} from \"./types.ts\";\n\nexport function parseAttrValue(\n  prop: AhxName | AhxAttributeName | AhxCSSPropertyName,\n  origin: Element,\n  expect: ValueType = \"tokens\",\n): string[] {\n  prop = asAhxAttributeName(prop);\n  const value = origin.getAttribute(prop) ?? undefined;\n  return value ? (expect === \"tokens\" ? value.split(/\\s+/) : [value]) : [];\n}\n\nexport function parseAttrOrCssValue(\n  prop: AhxName | AhxAttributeName | AhxCSSPropertyName,\n  origin: Element | CSSStyleRule,\n  expect: ValueType = \"tokens\",\n): string[] {\n  if (origin instanceof Element) {\n    return parseAttrValue(prop, origin, expect);\n  } else {\n    return parseCssValue(prop, origin, undefined, expect);\n  }\n}\n", "export function querySelectorExt(\n  elt: Element,\n  query?: string,\n): Element | undefined {\n  return _query(elt, query, false);\n}\n\nexport function querySelectorAllExt(\n  elt: Element,\n  query?: string,\n): Iterable<Element> {\n  return _query(elt, query, true);\n}\n\nfunction _query(\n  elt: Element,\n  query: string | undefined,\n  all: true,\n): Iterable<Element>;\nfunction _query(\n  elt: Element,\n  query: string | undefined,\n  all: false,\n): Element | undefined;\nfunction _query(\n  elt: Element,\n  query: string | undefined,\n  all: boolean,\n): Iterable<Element> | Element | undefined {\n  if (!query) {\n    return single();\n  }\n\n  const [axis, selector] = splitQuery(query);\n\n  switch (axis) {\n    case \"this\":\n      return single(elt);\n    case \"closest\":\n      return single(elt.closest(selector));\n    case \"find\":\n      return all\n        ? elt.querySelectorAll(selector)\n        : elt.querySelector(selector) ?? undefined;\n    case \"next\":\n      return single(next(elt, selector));\n    case \"previous\":\n      return single(previous(elt, selector));\n    case \"body\":\n      return single(elt.ownerDocument.body);\n    case \"document\":\n    case \"window\":\n      // for compatibility with htmx syntax, but we do not support\n      // returning the document or window\n      return single();\n    default:\n      return all\n        ? elt.ownerDocument.querySelectorAll(query)\n        : elt.ownerDocument.querySelector(query) ?? undefined;\n  }\n\n  function single(found?: Element | null) {\n    return all ? (found ? [found] : []) : (found ?? undefined);\n  }\n}\n\nfunction splitQuery(query: string) {\n  const spaceIndex = query.indexOf(\" \");\n  if (spaceIndex === -1) {\n    return [query, \"\"];\n  } else {\n    return [query.substring(0, spaceIndex), query.substring(spaceIndex + 1)];\n  }\n}\n\nfunction next(start: Element, selector: string) {\n  for (const elt of start.ownerDocument.querySelectorAll(selector)) {\n    if (\n      elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING\n    ) {\n      return elt;\n    }\n  }\n}\n\nfunction previous(start: Element, selector: string) {\n  const results = start.ownerDocument.querySelectorAll(selector);\n  for (let i = results.length - 1; i >= 0; i--) {\n    const elt = results[i];\n    if (\n      elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING\n    ) {\n      return elt;\n    }\n  }\n}\n", "/**\n * @template T\n * @this {ReadableStream<T>}\n */\nasync function* readableStreamIterator() {\n  const reader = this.getReader();\n  try {\n    let done, value;\n    do {\n      ({ done, value } = await reader.read());\n      if (value !== undefined) {\n        yield value;\n      }\n    } while (!done);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nReadableStream.prototype[Symbol.asyncIterator] ??= readableStreamIterator;\n", "/**\n * Parse a stream of HTML into Elements.\n *\n * Only emits child elements of the body once the parser moves\n * onto the next child element. All head elements are ignored,\n * as are non-element child nodes of the body (eg. comments, character data).\n *\n * The stream can be a series of individual HTML elements, not necessarily\n * enclosed within `<html>`/`<body>` tags, but proceeded by `<!DOCTYPE html>`,\n * and this would be a perfectly valid HTML5 document (as far as the parser\n * is concerned at least).\n *\n * @example\n * response.body\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new HTMLBodyElementParserStream(document));\n *\n * @extends {TransformStream<string, Element>}\n */\nexport class HTMLBodyElementParserStream extends TransformStream {\n  /**\n   * @param {Document} document will own the emitted elements\n   * @param {boolean} [template] extract content out of a template element\n   */\n  constructor(document, template) {\n    /** @type {Document} */\n    let parser;\n\n    /** @type {ParentNode} */\n    let container;\n\n    super({\n      start() {\n        // Create a temporary empty document to perform the parsing\n        parser = document.implementation.createHTMLDocument();\n      },\n\n      transform(chunk, controller) {\n        // Write each chunk into the document\n        parser.write(chunk);\n\n        // Determine the container once the first element is written\n        if (!container && parser.body?.childElementCount > 0) {\n          const element = parser.body.children[0];\n          if (template && element instanceof HTMLTemplateElement) {\n            // Set the container to the DocumentFragment in the template\n            container = element.content;\n          } else {\n            // Set the container to the body\n            container = parser.body;\n          }\n        }\n\n        // Once we have more than one element in the body we\n        // assume that all but the last element are complete\n        while (container?.childElementCount > 1) {\n          // Get the first element from the body\n          const element = container.children[0];\n\n          // Transfer the element ownership to the target document,\n          // this will also remove it from the body of the parser document\n          document.adoptNode(element);\n\n          // Emit the Element from the transformer\n          controller.enqueue(element);\n        }\n      },\n\n      flush(controller) {\n        // Transfer and emit any remaining elements from the body\n        for (const element of [...container?.children ?? []]) {\n          document.adoptNode(element);\n          controller.enqueue(element);\n        }\n        // Close the document for writing\n        parser.close();\n        parser = undefined;\n        container = undefined;\n      },\n    });\n  }\n}\n", "import { objectsWithInternal } from \"./internal.ts\";\n\nexport function findSlot(name: string, root: ParentNode) {\n  for (const [rule, slotNames] of objectsWithInternal(\"slotName\")) {\n    if (rule instanceof CSSStyleRule) {\n      if (slotNames.has(name)) {\n        const slot = root.querySelector(rule.selectorText);\n        if (slot) {\n          return slot;\n        }\n      }\n    }\n  }\n\n  for (const slot of root.querySelectorAll(`slot[name]`)) {\n    if (name === slot.getAttribute(\"name\")) {\n      return slot;\n    }\n  }\n}\n", "import \"../ext/polyfill/ReadableStream_asyncIterator.js\";\n\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { SwapHtmlDetail, SwapHtmlProps, SwapHtmlStyle } from \"./types.ts\";\nimport { HTMLBodyElementParserStream } from \"../ext/HTMLBodyElementParserStream.js\";\nimport { setOwner } from \"./util/owner.ts\";\nimport { config } from \"./config.ts\";\nimport { getInternal, setInternal } from \"./util/internal.ts\";\nimport { parseAttrValue } from \"./parse_attr_value.ts\";\nimport { findSlot } from \"./util/slots.ts\";\n\nexport async function swapHtml(props: SwapHtmlProps) {\n  const { response, target } = props;\n  const document = target.ownerDocument;\n  if (\n    response?.ok &&\n    response.headers.get(\"Content-Type\")?.startsWith(\"text/html\") &&\n    response.body\n  ) {\n    let index = 0;\n    let previous: Element | undefined;\n\n    const elements = response.body\n      .pipeThrough(new TextDecoderStream())\n      .pipeThrough(new HTMLBodyElementParserStream(document, true));\n\n    for await (const element of elements) {\n      const detail: SwapHtmlDetail = {\n        ...props,\n        swapStyle: props.swapStyle ?? \"none\",\n        element,\n        previous,\n        index,\n      };\n\n      const [slot] = parseAttrValue(\"slot\", element);\n\n      if (slot) {\n        detail.slot = slot;\n        const slotTarget = findSlot(slot, document);\n\n        if (slotTarget) {\n          detail.target = slotTarget;\n          detail.swapStyle = \"inner\";\n        } else {\n          detail.swapStyle = \"none\";\n        }\n      }\n\n      if (dispatchBefore(target, \"swap\", detail)) {\n        const { target, element, originOwner, swapStyle, slot } = detail;\n\n        if (originOwner) {\n          setOwner(element, originOwner);\n        }\n\n        if (slot || !previous) {\n          swapHandlers[swapStyle]?.(target, element);\n        } else {\n          previous.after(element);\n        }\n\n        if (!slot) {\n          previous = element;\n        }\n\n        dispatchAfter(target, \"swap\", detail);\n      }\n\n      index++;\n    }\n  }\n  // TODO: trigger events for non-ok response and non-html content\n}\n\ntype SwapHandler = (\n  target: Element,\n  element: Element,\n) => void;\n\nconst swapAdjacent =\n  (pos: InsertPosition): SwapHandler => (target, element) => {\n    target.insertAdjacentElement(pos, element);\n  };\n\nconst swapHandlers: Record<SwapHtmlStyle, SwapHandler> = {\n  none() {\n    // no-op\n  },\n  inner(target, element) {\n    target.replaceChildren(element);\n  },\n  outer(target, element) {\n    const pseudoPrefix = `${config.prefix}-pseudo`;\n\n    for (const cls of target.classList) {\n      if (cls.startsWith(pseudoPrefix)) {\n        element.classList.add(cls);\n      }\n    }\n\n    const triggeredOnce = getInternal(target, \"triggeredOnce\");\n    if (triggeredOnce) {\n      setInternal(element, \"triggeredOnce\", triggeredOnce);\n    }\n\n    target.replaceWith(element);\n  },\n  beforebegin: swapAdjacent(\"beforebegin\"),\n  afterbegin: swapAdjacent(\"afterbegin\"),\n  beforeend: swapAdjacent(\"beforeend\"),\n  afterend: swapAdjacent(\"afterend\"),\n};\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { SwapTextDetail, SwapTextProps } from \"./types.ts\";\n\nexport function swapAttr(props: SwapTextProps) {\n  const { target, itemName, merge } = props;\n\n  const detail: SwapTextDetail = {\n    ...props,\n  };\n\n  detail.oldValue = target.getAttribute(itemName) ?? undefined;\n\n  if (merge === \"join\" && detail.oldValue && detail.value) {\n    detail.value = join(detail.oldValue, detail.value);\n  }\n\n  if (dispatchBefore(target, \"swap\", detail)) {\n    const { target, itemName, value } = detail;\n\n    if (itemName && value !== undefined) {\n      target.setAttribute(itemName, value);\n    }\n\n    dispatchAfter(target, \"swap\", detail);\n  }\n}\n\nfunction join(oldValue: string, newValue: string) {\n  const sep = \" \";\n  const values = new Set(`${oldValue}${sep}${newValue}`.split(sep));\n  values.delete(\"\");\n  return [...values].join(sep);\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { getInternal } from \"./util/internal.ts\";\nimport type { SwapDetail, SwapTextProps } from \"./types.ts\";\n\nexport function swapInput(props: SwapTextProps) {\n  const { target, itemName, merge, value } = props;\n\n  if (!itemName || value === undefined) {\n    // TODO: consider dispatching an error event (at least for no itemName)\n    return;\n  }\n\n  const detail: SwapDetail = {\n    ...props,\n  };\n\n  if (target instanceof HTMLFormElement) {\n    detail.input = target.elements.namedItem(itemName) ?? undefined;\n\n    switch (merge) {\n      case \"append\":\n        detail.input = createInput(itemName, target.ownerDocument);\n        break;\n\n      default:\n        if (!detail.input) {\n          detail.input = createInput(itemName, target.ownerDocument);\n        } else if (\"value\" in detail.input) {\n          detail.oldValue = detail.input.value;\n        }\n        break;\n    }\n  } else {\n    detail.formData = getInternal(target, \"formData\", () => new FormData());\n    const oldValue = detail.formData.get(itemName);\n    if (typeof oldValue === \"string\") {\n      detail.oldValue = oldValue;\n    }\n  }\n\n  if (merge === \"join\") {\n    detail.value = join(detail.oldValue, detail.value);\n  }\n\n  if (dispatchBefore(target, \"swap\", detail)) {\n    const { target, input, itemName, merge, formData, value } = detail;\n\n    if (itemName && value !== undefined) {\n      if (input && \"value\" in input) {\n        input.value = value;\n        if (input instanceof Element && !input.parentElement) {\n          target.insertAdjacentElement(\"beforeend\", input);\n        }\n      } else if (formData) {\n        if (merge === \"append\") {\n          formData.append(itemName, value);\n        } else {\n          formData.set(itemName, value);\n        }\n      }\n    }\n\n    dispatchAfter(target, \"swap\", detail);\n  }\n}\n\nfunction createInput(name: string, document: Document) {\n  const input = document.createElement(\"input\");\n  input.type = \"hidden\";\n  input.name = name;\n  return input;\n}\n\nfunction join(oldValue = \"\", newValue = \"\") {\n  const sep = \" \";\n  const values = new Set(`${oldValue}${sep}${newValue}`.split(sep));\n  values.delete(\"\");\n  return [...values].join(sep);\n}\n", "import { swapAttr } from \"./swap_attr.ts\";\nimport { swapInput } from \"./swap_input.ts\";\nimport type { SwapTextProps } from \"./types.ts\";\n\nexport function swapText(props: SwapTextProps) {\n  const { swapStyle } = props;\n\n  switch (swapStyle) {\n    case \"input\":\n      return swapInput(props);\n    case \"attr\":\n      return swapAttr(props);\n  }\n}\n", "import { swapHtml } from \"./swap_html.ts\";\nimport { swapText } from \"./swap_text.ts\";\nimport type { SwapProps } from \"./types.ts\";\n\nexport async function handleSwap(props: SwapProps) {\n  const { swapStyle, response, itemName } = props;\n  let { value } = props;\n\n  switch (swapStyle) {\n    case \"input\":\n    case \"attr\": {\n      if (!itemName) {\n        // TODO: consider dispatching an error\n        return;\n      }\n\n      if (value === undefined && response) {\n        value = await response.text();\n        // TODO: handle errors\n      }\n\n      return swapText({\n        ...props,\n        swapStyle,\n        itemName,\n        value,\n      });\n    }\n\n    default:\n      if (isHtmlResponse(response)) {\n        return swapHtml({\n          ...props,\n          swapStyle: swapStyle ?? \"none\",\n          response,\n        });\n      }\n  }\n}\n\nfunction isHtmlResponse(response?: Response): response is Response {\n  return !!response?.headers.get(\"Content-Type\")?.startsWith(\"text/html\") &&\n    !!response.body;\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { handleSwap } from \"./handle_swap.ts\";\nimport type { ActionDetail, ActionRequestSpec } from \"./types.ts\";\n\nexport async function handleRequest(props: ActionDetail) {\n  const { source, action, target, swap, formData, originOwner, targetOwner } =\n    props;\n\n  if (action.type !== \"request\") {\n    return;\n  }\n\n  const detail = {\n    request: prepareRequest(action, formData),\n  };\n\n  if (dispatchBefore(source, \"request\", detail)) {\n    const { request } = detail;\n\n    try {\n      const response = await fetch(request);\n\n      dispatchAfter(source, \"request\", { request, response });\n\n      await handleSwap({\n        ...swap,\n        target,\n        response,\n        originOwner,\n        targetOwner,\n      });\n    } catch (error) {\n      dispatchAfter(source, \"request\", { request, error });\n    }\n  }\n}\n\nfunction prepareRequest(action: ActionRequestSpec, formData?: FormData) {\n  const url = new URL(action.url);\n\n  const init: RequestInit = {\n    method: action.method.toUpperCase(),\n  };\n\n  if (formData) {\n    switch (init.method) {\n      case \"GET\":\n      case \"HEAD\":\n      case \"DELETE\":\n        for (const [key, value] of formData) {\n          url.searchParams.append(key, String(value));\n        }\n        break;\n\n      case \"PUT\":\n      case \"POST\":\n      case \"PATCH\":\n        init.body = formData;\n    }\n  }\n\n  return new Request(url, init);\n}\n", "import type { ActionDetail, HarvestDetail } from \"./types.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { handleSwap } from \"./handle_swap.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\n\nexport async function handleHarvest(props: ActionDetail) {\n  const {\n    event,\n    source,\n    action,\n    target,\n    swap,\n    origin,\n    originOwner,\n    targetOwner,\n  } = props;\n\n  if (!(origin instanceof CSSStyleRule) || action.type !== \"harvest\") {\n    return;\n  }\n\n  const [newValue] = parseCssValue(\"harvest\", origin, source);\n\n  if (newValue === undefined) {\n    return;\n  }\n\n  const oldValue = getOldValue(event);\n\n  const detail: HarvestDetail = {\n    source,\n    oldValue,\n    newValue,\n    origin,\n    targetOwner,\n    originOwner,\n  };\n\n  if (dispatchBefore(source, \"harvest\", detail)) {\n    await handleSwap({\n      ...swap,\n      target,\n      value: detail.newValue,\n    });\n\n    dispatchAfter(source, \"harvest\", detail);\n  }\n}\n\nfunction getOldValue(event?: Event): string | undefined {\n  if (event instanceof CustomEvent && \"oldValue\" in event.detail) {\n    return event.detail.oldValue;\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { querySelectorExt } from \"./util/query_selector.ts\";\nimport { handleRequest } from \"./handle_request.ts\";\nimport { getInternal, hasInternal } from \"./util/internal.ts\";\nimport type { ActionDetail } from \"./types.ts\";\nimport { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { handleHarvest } from \"./handle_harvest.ts\";\n\nexport async function handleAction(detail: ActionDetail) {\n  const { source, origin } = detail;\n\n  const [query] = parseAttrOrCssValue(\"include\", origin, \"whole\");\n  const include = querySelectorExt(source, query);\n\n  detail.formData = include ? getFormData(include) : undefined;\n\n  if (dispatchBefore(source, \"handleAction\", detail)) {\n    switch (detail.action.type) {\n      case \"request\":\n        await handleRequest(detail);\n        break;\n\n      case \"harvest\":\n        await handleHarvest(detail);\n        break;\n    }\n\n    dispatchAfter(source, \"handleAction\", detail);\n  }\n}\n\nfunction getFormData(elt: Element): FormData | undefined {\n  if (hasInternal(elt, \"formData\")) {\n    return getInternal(elt, \"formData\");\n  }\n\n  if (elt instanceof HTMLFormElement) {\n    return new FormData(elt);\n  }\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport {\n  deleteInternal,\n  getInternal,\n  hasInternal,\n  setInternal,\n} from \"./util/internal.ts\";\nimport {\n  dispatchAfter,\n  dispatchBefore,\n  dispatchError,\n} from \"./util/dispatch.ts\";\nimport type { TriggerDetail } from \"./types.ts\";\nimport { handleAction } from \"./handle_action.ts\";\n\nexport function handleTrigger(detail: TriggerDetail) {\n  const { trigger, source } = detail;\n\n  if (isDenied(source)) {\n    dispatchError(source, \"triggerDenied\", detail);\n    return;\n  }\n\n  if (dispatchBefore(source, \"handleTrigger\", detail)) {\n    if (trigger?.once) {\n      if (hasInternal(source, \"triggeredOnce\")) {\n        return;\n      } else {\n        setInternal(source, \"triggeredOnce\", true);\n      }\n    }\n\n    if (trigger?.changed) {\n      // TODO: return if value hasn't changed\n    }\n\n    if (hasInternal(source, \"delayed\")) {\n      clearTimeout(getInternal(source, \"delayed\"));\n      deleteInternal(source, \"delayed\");\n    }\n\n    // TODO: throttle\n\n    if (trigger?.throttle) {\n      // TODO\n    } else if (trigger?.delay) {\n      // TODO\n    } else {\n      handleAction(detail);\n    }\n\n    dispatchAfter(source, \"handleTrigger\", detail);\n  }\n}\n\nexport function isDenied(elt: Element) {\n  // TODO: Should get calculated CSS value\n  const [deny] = parseAttrOrCssValue(\"deny-trigger\", elt);\n  return deny === \"true\";\n}\n", "/**\n * Resolve a given object to the most appropriate element, usually for triggering an event on.\n */\nexport function resolveElement(\n  origin: CSSRule | CSSStyleSheet | Element | null,\n): Element | undefined {\n  if (origin instanceof Element) {\n    return origin;\n  }\n  if (\n    origin && \"ownerNode\" in origin && origin.ownerNode &&\n    origin.ownerNode instanceof Element\n  ) {\n    return origin.ownerNode;\n  }\n  if (origin?.parentStyleSheet) {\n    return resolveElement(origin.parentStyleSheet);\n  }\n  if (origin && \"ownerRule\" in origin) {\n    return resolveElement(origin.ownerRule);\n  }\n}\n", "import { config } from \"../config.ts\";\n\nconst AHX_EVENTS = new Set([\"load\", \"watch\"]);\n\nexport function toDOMEventType(type: string) {\n  if (AHX_EVENTS.has(type)) {\n    return `${config.prefix}:${type}`;\n  }\n  return type;\n}\n\nexport function fromDOMEventType(type: string) {\n  const prefix = `${config.prefix}:`;\n  if (type.startsWith(prefix)) {\n    return type.substring(prefix.length);\n  }\n  return type;\n}\n", "export function isRuleEnabled(rule: CSSStyleRule): boolean {\n  return !!rule.parentStyleSheet && !rule.parentStyleSheet.disabled;\n}\n", "import type { EventType, Trigger } from \"../types.ts\";\nimport { getInternal, objectsWithInternal } from \"./internal.ts\";\nimport { isRuleEnabled } from \"./rules.ts\";\n\nexport function* getTriggersFromElements(\n  eventType: EventType,\n  root: Element,\n  recursive: boolean,\n): Iterable<[Element, Trigger]> {\n  const trigger = getInternal(root, `trigger:${eventType}`);\n\n  if (trigger) {\n    yield [root, trigger];\n  }\n\n  if (recursive) {\n    for (const [elt, trigger] of objectsWithInternal(`trigger:${eventType}`)) {\n      if (\n        elt instanceof Element && root.compareDocumentPosition(elt) &\n          Node.DOCUMENT_POSITION_CONTAINED_BY\n      ) {\n        yield [elt, trigger];\n      }\n    }\n  }\n}\n\nexport function* getTriggersFromRules(\n  eventType: EventType,\n  root: Element,\n  recursive: boolean,\n): Iterable<[Element, CSSStyleRule, Trigger]> {\n  for (const [rule, trigger] of objectsWithInternal(`trigger:${eventType}`)) {\n    if (trigger && rule instanceof CSSStyleRule && isRuleEnabled(rule)) {\n      // ... that match the element\n      if (root.matches(rule.selectorText)) {\n        yield [root, rule, trigger];\n      }\n\n      // ... on all sub-elements that match the selector\n      if (recursive) {\n        for (const elt of root.querySelectorAll(rule.selectorText)) {\n          yield [elt, rule, trigger];\n        }\n      }\n    }\n  }\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { querySelectorExt } from \"./util/query_selector.ts\";\n\nexport function parseTarget(elt: Element, rule?: CSSStyleRule): Element {\n  const [targetQuery] = parseAttrOrCssValue(\"target\", rule ?? elt, \"whole\");\n  return querySelectorExt(elt, targetQuery) ?? elt;\n}\n", "import { setInternal } from \"./util/internal.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { handleTrigger } from \"./handle_trigger.ts\";\nimport type {\n  ActionSpec,\n  EventType,\n  SwapSpec,\n  TriggerDetail,\n  TriggerOrigin,\n  TriggerSpec,\n} from \"./types.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { getOwner } from \"./util/owner.ts\";\nimport { fromDOMEventType, toDOMEventType } from \"./util/event.ts\";\nimport {\n  getTriggersFromElements,\n  getTriggersFromRules,\n} from \"./util/triggers.ts\";\nimport { parseTarget } from \"./parse_target.ts\";\n\nconst eventTypes = new Set<EventType>();\n\nexport function addTriggers(\n  origin: TriggerOrigin,\n  triggers: TriggerSpec[],\n  actions: ActionSpec[],\n  swap: SwapSpec,\n) {\n  for (const trigger of triggers) {\n    for (const action of actions) {\n      addTrigger(origin, trigger, action, swap);\n    }\n  }\n}\n\nexport function addTrigger(\n  origin: TriggerOrigin,\n  trigger: TriggerSpec,\n  action: ActionSpec,\n  swap: SwapSpec,\n) {\n  const detail = {\n    origin,\n    trigger,\n    action,\n    swap,\n  };\n\n  const target = resolveElement(origin) ?? document;\n\n  if (dispatchBefore(target, \"addTrigger\", detail)) {\n    const { trigger, action } = detail;\n    const { eventType } = trigger;\n\n    setInternal(origin, `trigger:${eventType}`, { trigger, action, swap });\n\n    if (!eventTypes.has(eventType)) {\n      const detail = { eventType };\n      if (dispatchBefore(document, \"addEventType\", detail)) {\n        eventTypes.add(eventType);\n\n        document.addEventListener(toDOMEventType(eventType), eventListener);\n\n        dispatchAfter(document, \"addEventType\", detail);\n      }\n    }\n\n    dispatchAfter(target, \"addTrigger\", detail);\n  }\n}\n\nexport function* getTriggersForEvent(\n  event: Event,\n): Iterable<TriggerDetail> {\n  if (event.target instanceof Element) {\n    const eventType = fromDOMEventType(event.type);\n    const root = event.target;\n    const recursive = event instanceof CustomEvent && !!event.detail?.recursive;\n\n    for (\n      const [source, trigger] of getTriggersFromElements(\n        eventType,\n        root,\n        recursive,\n      )\n    ) {\n      const sourceOwner = getOwner(source);\n      const target = parseTarget(source);\n      const targetOwner = getOwner(target);\n      yield {\n        ...trigger,\n        event,\n        source,\n        sourceOwner,\n        target,\n        targetOwner,\n        origin: source,\n        originOwner: sourceOwner,\n      };\n    }\n\n    // Find css rules with triggers\n    for (\n      const [source, origin, trigger] of getTriggersFromRules(\n        eventType,\n        root,\n        recursive,\n      )\n    ) {\n      const target = parseTarget(source, origin);\n      yield {\n        ...trigger,\n        event,\n        source,\n        sourceOwner: getOwner(source),\n        target,\n        targetOwner: getOwner(target),\n        origin,\n        originOwner: getOwner(origin),\n      };\n    }\n  }\n}\n\nfunction eventListener(event: Event) {\n  for (const triggered of getTriggersForEvent(event)) {\n    handleTrigger(triggered);\n  }\n}\n", "export function parseInterval(str?: string): number | undefined {\n  if (str == undefined) {\n    return undefined;\n  }\n  if (str.slice(-2) == \"ms\") {\n    return parseFloat(str.slice(0, -2)) || undefined;\n  }\n  if (str.slice(-1) == \"s\") {\n    return (parseFloat(str.slice(0, -1)) * 1000) || undefined;\n  }\n  if (str.slice(-1) == \"m\") {\n    return (parseFloat(str.slice(0, -1)) * 1000 * 60) || undefined;\n  }\n  return parseFloat(str) || undefined;\n}\n", "// Adapted from https://github.com/bigskysoftware/htmx/blob/master/src/htmx.js (see LICENSE_htmx)\n\nimport { parseInterval } from \"./parse_interval.ts\";\nimport { dispatchError } from \"./util/dispatch.ts\";\nimport type { TriggerOrigin, TriggerSpec } from \"./types.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\n\nconst WHITESPACE_OR_COMMA = /[\\s,]/;\nconst SYMBOL_START = /[_$a-zA-Z]/;\nconst SYMBOL_CONT = /[_$a-zA-Z0-9]/;\nconst STRINGISH_START = ['\"', \"'\", \"/\"];\nconst NOT_WHITESPACE = /[^\\s]/;\n\nexport function parseTriggers(\n  origin: TriggerOrigin,\n): TriggerSpec[] {\n  const [triggerValue] = parseAttrOrCssValue(\"trigger\", origin, \"whole\");\n  const triggerSpecs: TriggerSpec[] = [];\n  const target = resolveElement(origin);\n\n  if (triggerValue) {\n    const tokens = tokenizeString(triggerValue);\n    do {\n      consumeUntil(tokens, NOT_WHITESPACE);\n      const initialLength = tokens.length;\n      const trigger = consumeUntil(tokens, /[,\\[\\s]/);\n      if (trigger) {\n        if (trigger === \"every\") {\n          const every: TriggerSpec = { eventType: \"every\" };\n          consumeUntil(tokens, NOT_WHITESPACE);\n          every.pollInterval = parseInterval(consumeUntil(tokens, /[,\\[\\s]/));\n          consumeUntil(tokens, NOT_WHITESPACE);\n          triggerSpecs.push(every);\n        } else {\n          const triggerSpec: TriggerSpec = { eventType: trigger };\n          while (tokens.length > 0 && tokens[0] !== \",\") {\n            consumeUntil(tokens, NOT_WHITESPACE);\n            const token = tokens.shift();\n            if (token === \"changed\") {\n              triggerSpec.changed = true;\n            } else if (token === \"once\") {\n              triggerSpec.once = true;\n            } else if (token === \"delay\" && tokens[0] === \":\") {\n              tokens.shift();\n              triggerSpec.delay = parseInterval(\n                consumeUntil(tokens, WHITESPACE_OR_COMMA),\n              );\n            } else if (token === \"throttle\" && tokens[0] === \":\") {\n              tokens.shift();\n              triggerSpec.throttle = parseInterval(\n                consumeUntil(tokens, WHITESPACE_OR_COMMA),\n              );\n            } else if (token === \"queue\" && tokens[0] === \":\") {\n              tokens.shift();\n              // TODO: validate queue keyword\n              triggerSpec.queue = consumeUntil(\n                tokens,\n                WHITESPACE_OR_COMMA,\n              ) as typeof triggerSpec[\"queue\"];\n            } else {\n              dispatchError(target, \"triggerSyntax\", {\n                token: tokens.shift(),\n              });\n            }\n          }\n          triggerSpecs.push(triggerSpec);\n        }\n      }\n      if (tokens.length === initialLength) {\n        dispatchError(target, \"triggerSyntax\", {\n          token: tokens.shift(),\n        });\n      }\n      consumeUntil(tokens, NOT_WHITESPACE);\n    } while (tokens[0] === \",\" && tokens.shift());\n  }\n\n  return triggerSpecs;\n}\n\nfunction tokenizeString(str: string): string[] {\n  const tokens: string[] = [];\n  let position = 0;\n  while (position < str.length) {\n    if (SYMBOL_START.exec(str.charAt(position))) {\n      const startPosition = position;\n      while (SYMBOL_CONT.exec(str.charAt(position + 1))) {\n        position++;\n      }\n      tokens.push(str.substr(startPosition, position - startPosition + 1));\n    } else if (STRINGISH_START.indexOf(str.charAt(position)) !== -1) {\n      const startChar = str.charAt(position);\n      const startPosition = position;\n      position++;\n      while (position < str.length && str.charAt(position) !== startChar) {\n        if (str.charAt(position) === \"\\\\\") {\n          position++;\n        }\n        position++;\n      }\n      tokens.push(str.substr(startPosition, position - startPosition + 1));\n    } else {\n      const symbol = str.charAt(position);\n      tokens.push(symbol);\n    }\n    position++;\n  }\n  return tokens;\n}\n\nfunction consumeUntil(tokens: string[], match: string | RegExp): string {\n  let result = \"\";\n  while (tokens.length > 0 && !tokens[0].match(match)) {\n    result += tokens.shift();\n  }\n  return result;\n}\n", "import { config } from \"./config.ts\";\nimport { asAhxCSSPropertyName, getAhxCSSPropertyNames } from \"./util/names.ts\";\nimport { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport type { ActionSpec, TriggerOrigin } from \"./types.ts\";\n\nexport function parseActions(origin: TriggerOrigin): ActionSpec[] {\n  const actionSpecs: ActionSpec[] = [];\n\n  for (const method of config.httpMethods) {\n    const [url] = parseAttrOrCssValue(method, origin);\n    if (url) {\n      const baseURL = (resolveElement(origin) ?? document).baseURI;\n\n      actionSpecs.push({\n        type: \"request\",\n        method,\n        url: new URL(url, baseURL),\n      });\n    }\n  }\n\n  if (origin instanceof CSSStyleRule) {\n    if (getAhxCSSPropertyNames(origin).has(asAhxCSSPropertyName(\"harvest\"))) {\n      actionSpecs.push({\n        type: \"harvest\",\n      });\n    }\n  }\n\n  return actionSpecs;\n}\n", "import { parseAttrOrCssValue } from \"./parse_attr_value.ts\";\nimport { parseInterval } from \"./parse_interval.ts\";\nimport type { SwapSpec, SwapStyle, TriggerOrigin } from \"./types.ts\";\n\nexport function parseSwap(origin: TriggerOrigin) {\n  const tokens = parseAttrOrCssValue(\"swap\", origin, \"tokens\");\n\n  const swapSpec: SwapSpec = {};\n\n  if (tokens?.length) {\n    swapSpec.swapStyle = tokens.shift()?.toLowerCase() as SwapStyle;\n\n    if (swapSpec.swapStyle === \"attr\" || swapSpec.swapStyle === \"input\") {\n      swapSpec.itemName = tokens.shift();\n    }\n\n    for (const token of tokens) {\n      const [modifier, value] = token.split(\":\");\n      switch (modifier) {\n        case \"swap\":\n        case \"delay\":\n          swapSpec.delay = parseInterval(value);\n          break;\n        case \"join\":\n          swapSpec.merge = \"join\";\n          break;\n        case \"append\":\n          swapSpec.merge = \"append\";\n          break;\n      }\n    }\n  }\n\n  return swapSpec;\n}\n", "import { addTriggers } from \"./triggers.ts\";\nimport { parseTriggers } from \"./parse_triggers.ts\";\nimport type { TriggerOrigin } from \"./types.ts\";\nimport { parseActions } from \"./parse_actions.ts\";\nimport { parseSwap } from \"./parse_swap.ts\";\n\nexport function processTriggers(origin: TriggerOrigin) {\n  const triggers = parseTriggers(origin);\n  const actions = parseActions(origin);\n  const swap = parseSwap(origin);\n\n  addTriggers(origin, triggers, actions, swap);\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { hasAhxAttributes } from \"./util/names.ts\";\nimport { getOwner, setOwner } from \"./util/owner.ts\";\nimport { processTriggers } from \"./process_triggers.ts\";\n\nexport function processElement(elt: Element) {\n  if (hasAhxAttributes(elt)) {\n    const detail = {\n      owner: getOwner(elt),\n    };\n\n    if (dispatchBefore(elt, \"processElement\", detail)) {\n      if (detail.owner) {\n        setOwner(elt, detail.owner);\n      }\n\n      processTriggers(elt);\n\n      dispatchAfter(elt, \"processElement\", detail);\n    }\n  }\n}\n", "import { processElement } from \"./process_element.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { config } from \"./config.ts\";\nimport { asAhxAttributeName } from \"./util/names.ts\";\n\nexport function processElements(\n  root: ParentNode,\n) {\n  const selectors = new Set<string>();\n\n  [...config.ahxAttrs, ...config.httpMethods].forEach((attr) => {\n    selectors.add(`[${asAhxAttributeName(attr)}]`);\n  });\n\n  const detail = { selectors };\n\n  if (dispatchBefore(root, \"processElements\", detail)) {\n    const processed = new Set<Node>();\n\n    for (const selector of detail.selectors) {\n      if (\n        !processed.has(root) && root instanceof Element &&\n        root.matches(selector)\n      ) {\n        processed.add(root);\n        processElement(root);\n      }\n      for (const elt of root.querySelectorAll(selector)) {\n        if (!processed.has(elt)) {\n          processed.add(elt);\n          processElement(elt);\n        }\n      }\n    }\n\n    dispatchAfter(root, \"processElements\", detail);\n  }\n}\n", "import { dispatchOneShot } from \"./util/dispatch.ts\";\n\nexport function triggerMutate(elt: Element) {\n  dispatchOneShot(elt, \"mutate\", {});\n}\n", "import { dispatchOneShot } from \"./util/dispatch.ts\";\n\nexport function triggerLoad(elt: Element) {\n  dispatchOneShot(elt, \"load\", { recursive: true });\n}\n", "import { setInternal } from \"./util/internal.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\nimport { dispatchError } from \"./util/dispatch.ts\";\nimport type { AhxCSSPropertyName } from \"./types.ts\";\nimport { asAhxCSSPropertyName } from \"./util/names.ts\";\n\nexport function processGuards(\n  rule: CSSStyleRule,\n  props: Set<AhxCSSPropertyName>,\n) {\n  const prop = asAhxCSSPropertyName(\"deny-trigger\");\n\n  if (props.has(prop)) {\n    const [value] = parseCssValue(prop, rule);\n    if (value === \"true\") {\n      setInternal(rule, \"denyTrigger\", true);\n    } else {\n      rule.style.removeProperty(prop);\n      dispatchError(\n        rule.parentStyleSheet?.ownerNode ?? document,\n        \"invalidCssValue\",\n        {\n          prop,\n          value,\n          rule,\n        },\n      );\n    }\n  }\n\n  return [];\n}\n", "import { config } from \"./config.ts\";\nimport { getInternal, hasInternal, setInternal } from \"./util/internal.ts\";\nimport {\n  dispatchAfter,\n  dispatchBefore,\n  dispatchError,\n} from \"./util/dispatch.ts\";\nimport type { PseudoId, PseudoPlace } from \"./types.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { getOwner, setOwner } from \"./util/owner.ts\";\n\nlet nextPseudoId = 1;\n\nexport function processPseudoElements(\n  rule: CSSStyleRule,\n) {\n  // TODO: better selectorText parsing\n  const before = rule.selectorText.includes(\"::before\");\n  const after = before ? false : rule.selectorText.includes(\"::after\");\n\n  if (before || after) {\n    const pseudoId = getInternal(rule, \"pseudoId\") || nextPseudoId++;\n    const place = before ? \"before\" : \"after\";\n    const parentSelector = rule.selectorText.replace(`::${place}`, \"\");\n\n    for (const elt of document.querySelectorAll(parentSelector)) {\n      // Insert a 'pseudo-element'\n      createPseudoElement(elt, pseudoId, place);\n    }\n\n    return createPseudoRule(rule, pseudoId, place);\n  }\n}\n\nfunction createPseudoElement(\n  elt: Element,\n  pseudoId: PseudoId,\n  place: PseudoPlace,\n) {\n  const pseudoIdClass = `${config.prefix}-pseudo-${pseudoId}`;\n\n  if (!elt.querySelector(`:scope > .${pseudoIdClass}`)) {\n    const parentTag = elt.localName;\n\n    let pseudoTag = config.pseudoChildTags[parentTag];\n\n    if (pseudoTag === null) {\n      dispatchError(elt, \"pseudoElementNotPermitted\", { parentTag });\n      return;\n    }\n\n    if (pseudoTag === undefined) {\n      pseudoTag = config.pseudoChildTags[\"*\"] ?? \"span\";\n    }\n\n    const placeClass = `${config.prefix}-pseudo-${place}`;\n\n    const pseudoElt = document.createElement(pseudoTag);\n    pseudoElt.setAttribute(\n      \"class\",\n      `${config.prefix}-pseudo ${placeClass} ${pseudoIdClass}`,\n    );\n\n    const detail = {\n      pseudoElt,\n      pseudoId,\n      place,\n    };\n\n    if (dispatchBefore(elt, \"pseudoElement\", detail)) {\n      const insertPosition = detail.place === \"before\"\n        ? \"afterbegin\"\n        : \"beforeend\";\n\n      elt.insertAdjacentElement(insertPosition, detail.pseudoElt);\n\n      dispatchAfter(elt, \"pseudoElement\", detail);\n    }\n  }\n}\n\nfunction createPseudoRule(\n  rule: CSSStyleRule,\n  pseudoId: PseudoId,\n  place: PseudoPlace,\n) {\n  if (!hasInternal(rule, \"pseudoId\")) {\n    // Create a 'pseudo-rule' to target the 'pseudo-element'\n    setInternal(rule, \"pseudoId\", pseudoId);\n\n    const pseudoIdClass = `${config.prefix}-pseudo-${pseudoId}`;\n\n    const selectorText = rule.selectorText.replace(\n      `::${place}`,\n      ` > .${pseudoIdClass}`,\n    );\n    const cssText = rule.cssText.replace(rule.selectorText, selectorText);\n    const pseudoRule = {\n      selectorText,\n      cssText,\n      parentStyleSheet: rule.parentStyleSheet,\n    };\n\n    const detail = {\n      pseudoId,\n      pseudoRule,\n      rule,\n      place,\n      owner: getOwner(rule),\n    };\n\n    const target = resolveElement(rule) ?? document;\n\n    if (dispatchBefore(target, \"pseudoRule\", detail)) {\n      const styleSheet = detail.pseudoRule.parentStyleSheet;\n      if (styleSheet) {\n        const cssRules = styleSheet.cssRules;\n\n        const pseudoRule = cssRules[\n          styleSheet.insertRule(detail.pseudoRule.cssText, cssRules.length)\n        ] as CSSStyleRule;\n\n        if (!detail.owner && styleSheet.href) {\n          detail.owner = styleSheet.href;\n        }\n\n        if (detail.owner) {\n          setOwner(pseudoRule, detail.owner);\n        }\n\n        dispatchAfter(target, \"pseudoRule\", {\n          ...detail,\n          pseudoRule,\n        });\n\n        return pseudoRule;\n      }\n    }\n  }\n}\n", "import { getInternal } from \"./util/internal.ts\";\nimport { parseCssValue } from \"./parse_css_value.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { AhxCSSPropertyName, CssImportDetail } from \"./types.ts\";\nimport { asAhxCSSPropertyName } from \"./util/names.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\n\nexport function processCssImports(\n  rule: CSSStyleRule,\n  props: Set<AhxCSSPropertyName>,\n  onReady?: (link: HTMLLinkElement) => void,\n) {\n  const importProp = asAhxCSSPropertyName(\"import\");\n\n  for (const prop of props) {\n    if (prop === importProp || prop.startsWith(`${importProp}-`)) {\n      let link: HTMLLinkElement | undefined = getInternal(rule, \"importLinks\")\n        ?.get(prop)?.deref();\n      let ruleApplies = false;\n\n      for (const elt of document.querySelectorAll(rule.selectorText)) {\n        // TODO: consider getting computed style so that media queries are applied\n        // and/or allow media-queries to be appended to the prop value, like `@import`\n\n        const [url] = parseCssValue(prop, rule, elt);\n\n        if (url) {\n          ruleApplies = true;\n          if (link) {\n            if (link.sheet && link.sheet.disabled) {\n              link.sheet.disabled = false;\n              setTimeout(() => {\n                onReady?.(link!);\n              }, 0);\n            }\n            break;\n          } else {\n            link = createStyleSheetLink(\n              url,\n              (resolveElement(rule) as HTMLLinkElement)?.crossOrigin ??\n                undefined,\n              onReady,\n            );\n\n            if (link) {\n              getInternal(rule, \"importLinks\", () => new Map()).set(\n                prop,\n                new WeakRef(link),\n              );\n              break;\n            }\n          }\n        }\n      }\n\n      if (!ruleApplies && link && link.sheet && !link.sheet.disabled) {\n        link.sheet.disabled = true;\n      }\n    }\n  }\n}\n\nfunction createStyleSheetLink(\n  url: string,\n  crossOrigin?: string,\n  onReady?: (link: HTMLLinkElement) => void,\n): HTMLLinkElement | undefined {\n  const detail: CssImportDetail = { url, crossOrigin, disabled: false };\n\n  if (dispatchBefore(document, \"cssImport\", detail)) {\n    if (\n      !document.querySelector(`link[rel=\"stylesheet\"][href=\"${detail.url}\"]`)\n    ) {\n      const link = document.createElement(\"link\");\n      link.setAttribute(\"rel\", \"stylesheet\");\n      link.setAttribute(\"href\", detail.url);\n\n      if (typeof detail.crossOrigin === \"string\") {\n        link.setAttribute(\"crossorigin\", detail.crossOrigin);\n      }\n\n      link.addEventListener(\"load\", (event) => {\n        console.log(\"After load\", detail.url, link.sheet);\n        // IMPORTANT: The sheet object may not immediately appear in the DOM,\n        // even after the load event, so we may need to poll until it actually\n        // appears.\n        function process(delay = 1) {\n          setTimeout(() => {\n            console.log(\"After load + timeout\", detail.url, link.sheet);\n            if (link.sheet) {\n              dispatchAfter(event.target ?? document, \"cssImport\", detail);\n              onReady?.(link);\n            } else if (delay < 1000) {\n              process(delay * 2);\n            } else {\n              console.error(\"TIMEOUT\");\n            }\n          }, delay);\n        }\n\n        process();\n      }, { once: true, passive: true });\n\n      document.head.appendChild(link);\n      return link;\n    }\n  }\n}\n", "import { parseCssValue } from \"./parse_css_value.ts\";\nimport { getInternal } from \"./util/internal.ts\";\n\nexport function processSlot(rule: CSSStyleRule) {\n  const slotNames = parseCssValue(\"slot-name\", rule);\n  if (slotNames.length) {\n    const names = getInternal(rule, \"slotName\", () => new Set());\n    slotNames.forEach((name) => names.add(name));\n  }\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport type { AhxCSSPropertyName } from \"./types.ts\";\nimport { processTriggers } from \"./process_triggers.ts\";\nimport { processGuards } from \"./process_guards.ts\";\nimport { processPseudoElements } from \"./process_pseudo_elements.ts\";\nimport { getOwner, setOwner } from \"./util/owner.ts\";\nimport { resolveElement } from \"./util/resolve_element.ts\";\nimport { processCssImports } from \"./process_css_imports.ts\";\nimport { processRules } from \"./process_rules.ts\";\nimport { hasInternal } from \"./util/internal.ts\";\nimport { getAhxCSSPropertyNames } from \"./util/names.ts\";\nimport { triggerLoad } from \"./trigger_load.ts\";\nimport { processSlot } from \"./process_slot.ts\";\n\nexport function processRule(\n  rule: CSSStyleRule,\n  props: Set<AhxCSSPropertyName>,\n) {\n  if (rule.parentStyleSheet) {\n    processStyleSheet(rule.parentStyleSheet);\n  }\n\n  if (props.size) {\n    const owner = getOwner(rule);\n\n    const detail = { rule, props, owner };\n\n    // TODO: consider whether we should just NOT process\n    // any rule that doesn't have an associated node\n    const target = resolveElement(rule) ?? document;\n\n    if (dispatchBefore(target, \"processRule\", detail)) {\n      if (detail.owner) {\n        setOwner(rule, detail.owner);\n      }\n\n      processCssImports(rule, props, processImportedRules);\n      processGuards(rule, props);\n\n      const pseudoRule = processPseudoElements(rule);\n      if (pseudoRule) {\n        processRule(pseudoRule, getAhxCSSPropertyNames(pseudoRule));\n      }\n\n      processTriggers(rule);\n      processSlot(rule);\n\n      dispatchAfter(target, \"processRule\", detail);\n    }\n  }\n}\n\nfunction processStyleSheet(stylesheet: CSSStyleSheet) {\n  if (!hasInternal(stylesheet, \"owner\")) {\n    setOwner(stylesheet, stylesheet.href ?? \"unknown\");\n  }\n}\n\nfunction processImportedRules(link: HTMLLinkElement) {\n  processRules(link);\n  triggerLoad(link.ownerDocument.documentElement);\n}\n", "import { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { processRule } from \"./process_rule.ts\";\nimport { getAhxCSSPropertyNames } from \"./util/names.ts\";\nimport type { AhxCSSPropertyName } from \"./types.ts\";\n\nexport function processRules(\n  root: (DocumentOrShadowRoot | LinkStyle) & EventTarget,\n) {\n  const detail = {\n    rules: findRules(root),\n  };\n\n  if (dispatchBefore(root, \"processRules\", detail)) {\n    for (const [rule, props] of detail.rules) {\n      processRule(rule, props);\n    }\n\n    dispatchAfter(root, \"processRules\", detail);\n  }\n}\n\nfunction findRules(\n  root: DocumentOrShadowRoot | LinkStyle,\n): Map<CSSStyleRule, Set<AhxCSSPropertyName>> {\n  const rules = new Map<CSSStyleRule, Set<AhxCSSPropertyName>>();\n\n  function fromStylesheet(stylesheet: CSSStyleSheet) {\n    if (!stylesheet.disabled) {\n      try {\n        fromRuleList(stylesheet.cssRules);\n      } catch {\n        // Skip SecurityError\n      }\n    }\n  }\n\n  function fromRuleList(rules: CSSRuleList) {\n    for (const rule of rules) {\n      if (rule instanceof CSSImportRule && rule.styleSheet) {\n        fromStylesheet(rule.styleSheet);\n      } else if (rule instanceof CSSGroupingRule) {\n        fromRuleList(rule.cssRules);\n      } else if (rule instanceof CSSStyleRule) {\n        fromStyleRule(rule);\n      }\n    }\n  }\n\n  function fromStyleRule(rule: CSSStyleRule) {\n    const props = getAhxCSSPropertyNames(rule);\n    if (props.size > 0) {\n      rules.set(rule, props);\n    }\n  }\n\n  if (\"sheet\" in root && root.sheet) {\n    fromStylesheet(root.sheet);\n  } else if (\"styleSheets\" in root) {\n    for (const stylesheet of root.styleSheets) {\n      fromStylesheet(stylesheet);\n    }\n  }\n\n  return rules;\n}\n", "import { deleteInternal } from \"./util/internal.ts\";\nimport { processElement } from \"./process_element.ts\";\nimport { dispatchAfter, dispatchBefore } from \"./util/dispatch.ts\";\nimport { processElements } from \"./process_elements.ts\";\nimport { triggerMutate } from \"./trigger_mutate.ts\";\nimport { triggerLoad } from \"./trigger_load.ts\";\nimport { processRules } from \"./process_rules.ts\";\n\nexport function startObserver(root: Document) {\n  const observer = new MutationObserver((mutations) => {\n    const detail = { mutations };\n    if (dispatchBefore(root, \"mutations\", detail)) {\n      const removedNodes = new Set<Node>();\n      const removedElements = new Set<Element>();\n      const addedElements = new Set<Element>();\n      const mutatedElements = new Set<Element>();\n\n      for (const mutation of detail.mutations) {\n        for (const node of mutation.removedNodes) {\n          removedNodes.add(node);\n          if (node instanceof Element) {\n            removedElements.add(node);\n          }\n        }\n\n        for (const node of mutation.addedNodes) {\n          removedNodes.delete(node);\n          if (node instanceof Element) {\n            processElements(node);\n            addedElements.add(node);\n          }\n        }\n\n        if (\n          mutation.type === \"attributes\" && mutation.target instanceof Element\n        ) {\n          processElement(mutation.target);\n        }\n\n        if (mutation.target instanceof Element) {\n          mutatedElements.add(mutation.target);\n        }\n      }\n\n      setTimeout(() => {\n        for (const elt of mutatedElements) {\n          triggerMutate(elt);\n        }\n      }, 0);\n\n      setTimeout(() => {\n        for (const elt of addedElements) {\n          triggerLoad(elt);\n        }\n      });\n\n      processRules(root);\n\n      dispatchAfter(root, \"mutations\", {\n        ...detail,\n        removedElements,\n        addedElements,\n        mutatedElements,\n      });\n\n      for (const node of removedNodes) {\n        deleteInternalRecursive(node);\n      }\n    }\n  });\n\n  const options: MutationObserverInit = {\n    subtree: true,\n    childList: true,\n    attributes: true,\n    attributeOldValue: true,\n  };\n\n  if (dispatchBefore(root, \"startObserver\", options)) {\n    observer.observe(root, options);\n\n    dispatchAfter(root, \"startObserver\", options);\n  }\n}\n\nfunction deleteInternalRecursive(node: Node) {\n  deleteInternal(node);\n  for (const child of node.childNodes) {\n    deleteInternalRecursive(child);\n  }\n}\n", "import { config } from \"../config.ts\";\nimport type { AhxEventType, EventType } from \"../types.ts\";\n\ninterface LoggerConfig {\n  group: boolean | \"collapse\";\n  include: (AhxEventType | \"error\" | \"veto\")[];\n}\n\nexport const loggerConfig: LoggerConfig = {\n  group: false,\n  include: [],\n};\n\nexport function eventsAll() {\n  config.enableDebugEvent = true;\n  addEventListener(config.prefix, logger);\n}\n\nexport function eventsNone() {\n  config.enableDebugEvent = false;\n  removeEventListener(config.prefix, logger);\n}\n\nexport function logger({ detail: event }: CustomEvent<CustomEvent>) {\n  const { type, target, detail } = event;\n\n  if (shouldLog(type)) {\n    if (detail?._after && loggerConfig.group) {\n      console.groupEnd();\n    }\n\n    if (detail?._before) {\n      const method = loggerConfig.group\n        ? loggerConfig.group === true ? \"group\" : \"groupCollapsed\"\n        : \"debug\";\n\n      console[method](\"%s -> %o %o\", type, target, detail);\n    } else {\n      console.debug(\"%s -> %o %o\", type, target, detail);\n    }\n  }\n}\n\nfunction shouldLog(type: EventType): boolean {\n  if (loggerConfig.include?.length) {\n    if (loggerConfig.include.some((v) => type.includes(`:${v}`))) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\n", "export * from \"./debug/internals.ts\";\nexport * from \"./debug/events.ts\";\nexport * from \"./debug/elements.ts\";\nexport * from \"./debug/triggers.ts\";\nexport * from \"./debug/owners.ts\";\nexport * from \"./debug/forms.ts\";\n", "import { internalEntries } from \"../util/internal.ts\";\n\nexport function internals() {\n  console.group(\"AHX Internal Properties\");\n\n  let groupObject: unknown;\n  for (const [object, key, value] of internalEntries()) {\n    if (object !== groupObject) {\n      if (groupObject) {\n        console.groupEnd();\n      }\n\n      const representation = object instanceof CSSRule\n        ? object.cssText\n        : object;\n\n      console.groupCollapsed(representation);\n      console.dir(object);\n\n      if (object instanceof CSSStyleRule) {\n        // console.groupCollapsed('matched nodes...');\n        for (const node of document.querySelectorAll(object.selectorText)) {\n          console.log(node);\n        }\n        // console.groupEnd();\n      }\n\n      groupObject = object;\n    }\n\n    if (value instanceof Map) {\n      console.group(\"%s:\", key);\n      for (const entry of value) {\n        console.log(\"%c%s:\", \"font-weight: bold\", ...entry);\n      }\n      console.groupEnd();\n    } else {\n      console.log(\"%c%s:\", \"font-weight: bold\", key, value);\n    }\n  }\n\n  console.groupEnd();\n}\n", "export function comparePosition(a: Node, b: Node) {\n  if (a === b) {\n    return 0;\n  }\n\n  const position = a.compareDocumentPosition(b);\n\n  if (\n    position & Node.DOCUMENT_POSITION_FOLLOWING ||\n    position & Node.DOCUMENT_POSITION_CONTAINED_BY\n  ) {\n    return -1;\n  } else if (\n    position & Node.DOCUMENT_POSITION_PRECEDING ||\n    position & Node.DOCUMENT_POSITION_CONTAINS\n  ) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n", "import { parseAttrValue } from \"../parse_attr_value.ts\";\nimport { internalEntries } from \"../util/internal.ts\";\nimport type { AhxName } from \"../types.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function elements(ahxProp?: AhxName) {\n  console.group(\"AHX Elements\");\n\n  const elements = new Set<Element>();\n  const rules = new Set<CSSStyleRule>();\n\n  for (const [object] of internalEntries()) {\n    if (object instanceof Element) {\n      elements.add(object);\n    } else if (object instanceof CSSStyleRule) {\n      rules.add(object);\n    }\n  }\n\n  for (const rule of rules) {\n    for (const node of document.querySelectorAll(rule.selectorText)) {\n      if (node instanceof Element) {\n        elements.add(node);\n      }\n    }\n  }\n\n  for (const elt of [...elements].sort(comparePosition)) {\n    if (ahxProp) {\n      const tokens = parseAttrValue(ahxProp, elt);\n      if (tokens.length) {\n        console.log(elt, ...tokens);\n      }\n    } else {\n      console.log(elt);\n    }\n  }\n\n  console.groupEnd();\n}\n", "import { isDenied } from \"../handle_trigger.ts\";\nimport { internalEntries } from \"../util/internal.ts\";\nimport type { EventType, Trigger, TriggerOrigin } from \"../types.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function triggers(verbose = false) {\n  console.group(\"AHX Triggers\");\n\n  const elements = new Map<Element, Map<Trigger, TriggerOrigin>>();\n\n  function addOrigin(elt: Element, origin: TriggerOrigin, trigger: Trigger) {\n    if (!elements.has(elt)) {\n      elements.set(elt, new Map());\n    }\n    elements.get(elt)!.set(trigger, origin);\n  }\n\n  for (const [origin, key, trigger] of internalEntries()) {\n    if (key.startsWith(\"trigger:\")) {\n      if (origin instanceof Element) {\n        addOrigin(origin, origin, trigger as Trigger);\n      } else if (origin instanceof CSSStyleRule) {\n        for (const node of document.querySelectorAll(origin.selectorText)) {\n          if (node instanceof Element) {\n            addOrigin(node, origin, trigger as Trigger);\n          }\n        }\n      }\n    }\n  }\n\n  const orderedElements = [...elements.keys()].sort(comparePosition);\n\n  for (const elt of orderedElements) {\n    const triggers = elements.get(elt) ?? [];\n    const events = new Set<EventType>();\n    const denied = isDenied(elt);\n\n    for (const [{ trigger }] of triggers) {\n      events.add(trigger.eventType);\n    }\n\n    console.groupCollapsed(\n      \"%o : %c%s\",\n      elt,\n      denied ? \"text-decoration: line-through; color: grey\" : \"color: red\",\n      [...events].join(\", \"),\n    );\n\n    for (const [{ trigger, action, swap }, origin] of triggers) {\n      if (verbose) {\n        console.log(\n          \"trigger:\",\n          trigger,\n          \"action:\",\n          action,\n          \"origin:\",\n          origin,\n        );\n      } else {\n        const originRep = origin instanceof Element\n          ? \"element\"\n          : origin.cssText;\n\n        const actionRep = \"method\" in action\n          ? `${action.method.toUpperCase()} ${action.url}`\n          : action.type;\n\n        const swapRep = (swap.swapStyle ?? \"default\") +\n          (swap.itemName ? ` ${swap.itemName}` : \"\");\n\n        console.log(\n          \"%c%s%c -> %c%s%c -> %c%s%c from: %c%s%c\",\n          \"color: red; font-weight: bold\",\n          trigger.eventType,\n          \"color: inherit; font-weight: normal\",\n          \"color: green\",\n          actionRep,\n          \"color: inherit\",\n          \"color: darkorange\",\n          swapRep,\n          \"color: inherit\",\n          \"color: hotpink\",\n          originRep,\n          \"color: inherit\",\n        );\n      }\n    }\n\n    console.groupEnd();\n  }\n\n  console.groupEnd();\n}\n", "import { getInternal, internalEntries } from \"../util/internal.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\n\nexport function owners() {\n  console.group(\"AHX Ownership\");\n\n  const elements = new Set<Element>();\n\n  for (const [object, key, owner] of internalEntries()) {\n    if (object instanceof Element) {\n      elements.add(object);\n    } else if (key === \"owner\") {\n      if (object instanceof CSSRule) {\n        console.log(\"%o -> %s\", object.cssText, owner);\n      } else {\n        console.log(\"%o -> %s\", object, owner);\n      }\n    }\n  }\n\n  for (const elt of [...elements].sort(comparePosition)) {\n    const owner = getInternal(elt, \"owner\");\n    console.log(\"%o -> %s\", elt, owner ?? \"none\");\n  }\n\n  console.groupEnd();\n}\n", "import { isRuleEnabled } from \"../util/rules.ts\";\nimport {\n  getInternal,\n  internalEntries,\n  objectsWithInternal,\n} from \"../util/internal.ts\";\nimport { comparePosition } from \"./compare_position.ts\";\nimport type { ActionType, Trigger } from \"../types.ts\";\nimport { parseTarget } from \"../parse_target.ts\";\n\nexport function forms() {\n  console.group(\"AHX Forms\");\n\n  const elements = new Set<Element>();\n\n  for (const [elt] of objectsWithInternal(\"formData\")) {\n    if (elt instanceof Element) {\n      elements.add(elt);\n    }\n  }\n\n  for (const [rule] of getTriggerRulesByAction(\"harvest\")) {\n    for (const elt of document.querySelectorAll(rule.selectorText)) {\n      elements.add(parseTarget(elt, rule));\n    }\n  }\n\n  for (const elt of [...elements].sort(comparePosition)) {\n    const formData = elt instanceof HTMLFormElement\n      ? new FormData(elt)\n      : getInternal(elt, \"formData\");\n\n    if (formData) {\n      console.group(elt);\n\n      for (const [name, value] of formData ?? []) {\n        console.log(\"%s: %c%s\", name, \"font-weight: bold\", value);\n      }\n\n      console.groupEnd();\n    }\n  }\n\n  console.groupEnd();\n}\n\nfunction* getTriggerRulesByAction(\n  type: ActionType,\n): Iterable<[CSSStyleRule, Trigger]> {\n  for (const [rule, key, trigger] of internalEntries()) {\n    if (\n      key.startsWith(\"trigger:\") && rule instanceof CSSStyleRule &&\n      typeof trigger === \"object\" && \"action\" in trigger &&\n      trigger.action.type === type && isRuleEnabled(rule)\n    ) {\n      yield [rule, trigger as Trigger];\n    }\n  }\n}\n", "import { config } from \"./config.ts\";\n\nexport function applyUrlAttrs(elt: Element, loc: Location) {\n  if (elt && elt.getAttribute(`${config.prefix}-url-href`) !== loc.href) {\n    setAttr(\"href\", loc.href);\n    setAttr(\"host\", loc.host);\n    setAttr(\"path\", loc.pathname);\n    setAttr(\"search\", loc.search);\n    setAttr(\"hash\", loc.hash);\n  }\n\n  function setAttr(prop: string, value?: string) {\n    const attr = `${config.prefix}-url-${prop}`;\n    if (value) {\n      elt.setAttribute(attr, value);\n    } else {\n      elt.removeAttribute(attr);\n    }\n  }\n}\n\nexport function initUrlAttrs(document: Document) {\n  function listener() {\n    applyUrlAttrs(document.documentElement, document.location);\n  }\n\n  [\n    \"DOMContentLoaded\",\n    \"load\",\n    \"hashchange\",\n    \"popstate\",\n  ]\n    .forEach((event) => {\n      addEventListener(event, listener);\n    });\n\n  listener();\n}\n", "/// <reference lib=\"dom\"/>\n/// <reference lib=\"dom.iterable\"/>\n/// <reference lib=\"dom.asynciterable\"/>\n\nimport { ready } from \"./ready.ts\";\nimport { startObserver } from \"./start_observer.ts\";\nimport { eventsAll } from \"./debug/events.ts\";\nimport { processElements } from \"./process_elements.ts\";\nimport { processRules } from \"./process_rules.ts\";\nimport * as ahx from \"./debug.ts\";\nimport { initUrlAttrs } from \"./url_attrs.ts\";\nimport { triggerLoad } from \"./trigger_load.ts\";\n\n// ahx.loggerConfig.include = [\"processValue\", \"updateForm\"];\n\nready((document) => {\n  eventsAll();\n\n  initUrlAttrs(document);\n\n  startObserver(document);\n\n  processRules(document);\n\n  processElements(document);\n\n  triggerLoad(document.documentElement);\n});\n\n// deno-lint-ignore no-explicit-any\n(window as any).ahx = ahx;\n"],
  "mappings": "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",
  "names": ["isReady", "ready", "fn", "values", "weakRefs", "toWeakRef", "setInternal", "obj", "key", "value", "weakRef", "getInternal", "initializer", "hasInternal", "deleteInternal", "valueMap", "objectsWithInternal", "internalEntries", "config", "dispatch", "target", "type", "detail", "cancelable", "event", "config", "dispatchOneShot", "name", "dispatchBefore", "permitted", "dispatchAfter", "dispatchError", "getAhxCSSPropertyNames", "rule", "names", "name", "isAhxCSSPropertyName", "hasAhxAttributes", "elt", "attr", "isAhxAttributeName", "config", "asAhxCSSPropertyName", "asAhxAttributeName", "getOwner", "origin", "hasInternal", "getInternal", "setOwner", "owner", "setInternal", "parseCssValue", "prop", "rule", "elt", "expect", "asAhxCSSPropertyName", "value", "isAttr", "parseURL", "isProp", "propValue", "isURL", "parseQuoted", "baseURL", "e", "isQuoted", "parseAttrValue", "prop", "origin", "expect", "asAhxAttributeName", "value", "parseAttrOrCssValue", "parseCssValue", "querySelectorExt", "elt", "query", "_query", "_query", "elt", "query", "all", "single", "axis", "selector", "splitQuery", "next", "previous", "found", "spaceIndex", "start", "results", "i", "readableStreamIterator", "reader", "done", "value", "HTMLBodyElementParserStream", "document", "template", "parser", "container", "chunk", "controller", "element", "findSlot", "name", "root", "rule", "slotNames", "objectsWithInternal", "slot", "swapHtml", "props", "response", "target", "document", "index", "previous", "elements", "HTMLBodyElementParserStream", "element", "detail", "slot", "parseAttrValue", "slotTarget", "findSlot", "dispatchBefore", "originOwner", "swapStyle", "setOwner", "swapHandlers", "dispatchAfter", "swapAdjacent", "pos", "pseudoPrefix", "config", "cls", "triggeredOnce", "getInternal", "setInternal", "swapAttr", "props", "target", "itemName", "merge", "detail", "join", "dispatchBefore", "value", "dispatchAfter", "oldValue", "newValue", "sep", "values", "swapInput", "props", "target", "itemName", "merge", "value", "detail", "createInput", "getInternal", "oldValue", "join", "dispatchBefore", "input", "formData", "dispatchAfter", "name", "document", "newValue", "sep", "values", "swapText", "props", "swapStyle", "swapInput", "swapAttr", "handleSwap", "props", "swapStyle", "response", "itemName", "value", "swapText", "isHtmlResponse", "swapHtml", "handleRequest", "props", "source", "action", "target", "swap", "formData", "originOwner", "targetOwner", "detail", "prepareRequest", "dispatchBefore", "request", "response", "dispatchAfter", "handleSwap", "error", "url", "init", "key", "value", "handleHarvest", "props", "event", "source", "action", "target", "swap", "origin", "originOwner", "targetOwner", "newValue", "parseCssValue", "oldValue", "getOldValue", "detail", "dispatchBefore", "handleSwap", "dispatchAfter", "handleAction", "detail", "source", "origin", "query", "parseAttrOrCssValue", "include", "querySelectorExt", "getFormData", "dispatchBefore", "handleRequest", "handleHarvest", "dispatchAfter", "elt", "hasInternal", "getInternal", "handleTrigger", "detail", "trigger", "source", "isDenied", "dispatchError", "dispatchBefore", "hasInternal", "setInternal", "getInternal", "deleteInternal", "handleAction", "dispatchAfter", "elt", "deny", "parseAttrOrCssValue", "resolveElement", "origin", "AHX_EVENTS", "toDOMEventType", "type", "config", "fromDOMEventType", "prefix", "isRuleEnabled", "rule", "getTriggersFromElements", "eventType", "root", "recursive", "trigger", "getInternal", "elt", "objectsWithInternal", "getTriggersFromRules", "rule", "isRuleEnabled", "parseTarget", "elt", "rule", "targetQuery", "parseAttrOrCssValue", "querySelectorExt", "eventTypes", "addTriggers", "origin", "triggers", "actions", "swap", "trigger", "action", "addTrigger", "detail", "target", "resolveElement", "dispatchBefore", "eventType", "setInternal", "toDOMEventType", "eventListener", "dispatchAfter", "getTriggersForEvent", "event", "fromDOMEventType", "root", "recursive", "source", "getTriggersFromElements", "sourceOwner", "getOwner", "parseTarget", "targetOwner", "getTriggersFromRules", "triggered", "handleTrigger", "parseInterval", "str", "WHITESPACE_OR_COMMA", "SYMBOL_START", "SYMBOL_CONT", "STRINGISH_START", "NOT_WHITESPACE", "parseTriggers", "origin", "triggerValue", "parseAttrOrCssValue", "triggerSpecs", "target", "resolveElement", "tokens", "tokenizeString", "consumeUntil", "initialLength", "trigger", "every", "parseInterval", "triggerSpec", "token", "dispatchError", "str", "position", "startPosition", "startChar", "symbol", "match", "result", "parseActions", "origin", "actionSpecs", "method", "config", "url", "parseAttrOrCssValue", "baseURL", "resolveElement", "getAhxCSSPropertyNames", "asAhxCSSPropertyName", "parseSwap", "origin", "tokens", "parseAttrOrCssValue", "swapSpec", "token", "modifier", "value", "parseInterval", "processTriggers", "origin", "triggers", "parseTriggers", "actions", "parseActions", "swap", "parseSwap", "addTriggers", "processElement", "elt", "hasAhxAttributes", "detail", "getOwner", "dispatchBefore", "setOwner", "processTriggers", "dispatchAfter", "processElements", "root", "selectors", "config", "attr", "asAhxAttributeName", "detail", "dispatchBefore", "processed", "selector", "processElement", "elt", "dispatchAfter", "triggerMutate", "elt", "dispatchOneShot", "triggerLoad", "elt", "dispatchOneShot", "processGuards", "rule", "props", "prop", "asAhxCSSPropertyName", "value", "parseCssValue", "setInternal", "dispatchError", "nextPseudoId", "processPseudoElements", "rule", "before", "after", "pseudoId", "getInternal", "place", "parentSelector", "elt", "createPseudoElement", "createPseudoRule", "pseudoIdClass", "config", "parentTag", "pseudoTag", "dispatchError", "placeClass", "pseudoElt", "detail", "dispatchBefore", "insertPosition", "dispatchAfter", "hasInternal", "setInternal", "selectorText", "cssText", "pseudoRule", "getOwner", "target", "resolveElement", "styleSheet", "cssRules", "setOwner", "processCssImports", "rule", "props", "onReady", "importProp", "asAhxCSSPropertyName", "prop", "link", "getInternal", "ruleApplies", "elt", "url", "parseCssValue", "createStyleSheetLink", "resolveElement", "crossOrigin", "detail", "dispatchBefore", "event", "process", "delay", "dispatchAfter", "processSlot", "rule", "slotNames", "parseCssValue", "names", "getInternal", "name", "processRule", "rule", "props", "processStyleSheet", "owner", "getOwner", "detail", "target", "resolveElement", "dispatchBefore", "setOwner", "processCssImports", "processImportedRules", "processGuards", "pseudoRule", "processPseudoElements", "getAhxCSSPropertyNames", "processTriggers", "processSlot", "dispatchAfter", "stylesheet", "hasInternal", "link", "processRules", "triggerLoad", "processRules", "root", "detail", "findRules", "dispatchBefore", "rule", "props", "processRule", "dispatchAfter", "rules", "fromStylesheet", "stylesheet", "fromRuleList", "fromStyleRule", "getAhxCSSPropertyNames", "startObserver", "root", "observer", "mutations", "detail", "dispatchBefore", "removedNodes", "removedElements", "addedElements", "mutatedElements", "mutation", "node", "processElements", "processElement", "elt", "triggerMutate", "triggerLoad", "processRules", "dispatchAfter", "deleteInternalRecursive", "options", "deleteInternal", "child", "loggerConfig", "eventsAll", "config", "logger", "eventsNone", "event", "type", "target", "detail", "shouldLog", "method", "v", "debug_exports", "__export", "elements", "eventsAll", "eventsNone", "forms", "internals", "logger", "loggerConfig", "owners", "triggers", "internals", "groupObject", "object", "key", "value", "internalEntries", "representation", "node", "entry", "comparePosition", "a", "b", "position", "elements", "ahxProp", "rules", "object", "internalEntries", "rule", "node", "elt", "comparePosition", "tokens", "parseAttrValue", "triggers", "verbose", "elements", "addOrigin", "elt", "origin", "trigger", "key", "internalEntries", "node", "orderedElements", "comparePosition", "events", "denied", "isDenied", "action", "swap", "originRep", "actionRep", "swapRep", "owners", "elements", "object", "key", "owner", "internalEntries", "elt", "comparePosition", "getInternal", "forms", "elements", "elt", "objectsWithInternal", "rule", "getTriggerRulesByAction", "parseTarget", "comparePosition", "formData", "getInternal", "name", "value", "type", "key", "trigger", "internalEntries", "isRuleEnabled", "applyUrlAttrs", "elt", "loc", "config", "setAttr", "prop", "value", "attr", "initUrlAttrs", "document", "listener", "event", "ready", "document", "eventsAll", "initUrlAttrs", "startObserver", "processRules", "processElements", "triggerLoad", "debug_exports"]
}
